
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Hierarchical TAD Identification &#8212; TADLib 0.5.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Hierarchical TAD" href="hitad.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">TADLib</a></h1>



<p class="blurb">A Library to Explore Chromatin Interaction Patterns for Topologically Associating Domains</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=XiaoTaoWang&repo=TADLib&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Install TADLib</a></li>
<li class="toctree-l1"><a class="reference internal" href="calfea.html">Aggregation Preference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="hitad.html">Hierarchical TAD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hitad.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="hitad.html#snapshot">Snapshot</a></li>
<li class="toctree-l2"><a class="reference internal" href="hitad.html#tutorial">Tutorial</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="hitad.html#id1">API Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Hierarchical TAD Identification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domain-loading-and-aligning">Domain Loading and Aligning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Release Notes</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="hierarchical-tad-identification">
<h1>Hierarchical TAD Identification<a class="headerlink" href="#hierarchical-tad-identification" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="tadlib.hitad.chromLev.Chrom">
<em class="property">class </em><code class="descclassname">tadlib.hitad.chromLev.</code><code class="descname">Chrom</code><span class="sig-paren">(</span><em>chrom</em>, <em>res</em>, <em>hicdata</em>, <em>replabel</em>, <em>maxapart=4000000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Chrom</em> is defined to:</p>
<ul class="simple">
<li>Hold Hi-C data within a certain chromosome</li>
<li>Identify hierarchical domains in 4 steps: 1.Calculate adaptive DIs.
2.Identify original candidate bounds by 5-state Gaussian mixture Hidden
Markov Model using adaptive DIs as input. 3.Select TAD bounds from
candidate bounds. 4.Recursively identify inner domain structures of each TAD.</li>
<li>Visualize any region of the chromosome. Hierarchical domains will be
plotted as boxes along with the diagonal of the heatmap, and adaptive
DI track will be placed on top of the heatmap.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>hicdata</strong> <span class="classifier-delimiter">:</span> <span class="classifier">CSR sparse matrix</span></dt>
<dd><p class="first last">Bin-level Hi-C matrix of the specified chromosome.</p>
</dd>
<dt><strong>replabel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Biological replicate label.</p>
</dd>
<dt><strong>maxapart</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum allowable TAD size in base-pair unit. (Default: 4000000)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Resolution in base-pair unit.</p>
</dd>
<dt><strong>maxapart</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum allowable TAD size.</p>
</dd>
<dt><strong>replabel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Biological replicate label.</p>
</dd>
<dt><strong>chromLen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Total bin number of the chromosome.</p>
</dd>
<dt><strong>rawMatrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sparse matrix in Compressed Sparse Row format</span></dt>
<dd><p class="first last">CSR sparse matrix is used to extract Hi-C data by slicing conveniently
while guarantee low memory overhead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calDI</span></code></a>(windows,&nbsp;start)</td>
<td>Calculate Directionality Index (DI) for each bin with adaptive window size.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.callDomain" title="tadlib.hitad.chromLev.Chrom.callDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callDomain</span></code></a>()</td>
<td>Direct API for our hierarchical domain identification pipeline:</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="tadlib.hitad.chromLev.Chrom.detectPeaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detectPeaks</span></code></a>(trends[,&nbsp;mph,&nbsp;mpd])</td>
<td>Detect peaks (local maxima) in a 1-D array intuitively (a peak must be greater than its immediate neighbors).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="tadlib.hitad.chromLev.Chrom.fineDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fineDomain</span></code></a>()</td>
<td>Identify hierarchical domains within each TAD.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getDomainList" title="tadlib.hitad.chromLev.Chrom.getDomainList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDomainList</span></code></a>(byregion)</td>
<td>Combine by-region domains into a single list.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getSelfMatrix" title="tadlib.hitad.chromLev.Chrom.getSelfMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSelfMatrix</span></code></a>(start,&nbsp;end)</td>
<td>Return the contact matrix of any given region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="tadlib.hitad.chromLev.Chrom.getWeightMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getWeightMatrix</span></code></a>(start,&nbsp;end[,&nbsp;bases])</td>
<td>Calculate weights for each intra-domain interaction by considering the genomic distance and the local interaction background.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="tadlib.hitad.chromLev.Chrom.idxmatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">idxmatch</span></code></a>(domain)</td>
<td>Pair interactions of the given domain with the upstream and downstream interactions under the same genomic distance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterCore</span></code></a>(minDomains,&nbsp;tmpDomains)</td>
<td>Calculate the mismatch ratio for the input two domain lists.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxCore</span></code></a>([cache])</td>
<td>Perform TAD identification.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxscorepath</span></code></a>(domainlist,&nbsp;cache)</td>
<td>An implementation for our proposed algorithm to find the best separation solution at chromosomal/domain level, given bottom domain list and pre-computed scores.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minCore" title="tadlib.hitad.chromLev.Chrom.minCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minCore</span></code></a>(regionDIs)</td>
<td>Output domain list for each gap-free region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minWindows</span></code></a>(start,&nbsp;end,&nbsp;maxw)</td>
<td>Estimate best window size for each bin of a given range.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriIter</span></code></a>(minDomains)</td>
<td>Iteratvely approximate adaptive window sizes and return the final bottom domain list which will be used in subsequent procedures.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="tadlib.hitad.chromLev.Chrom.oriWindow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriWindow</span></code></a>(P)</td>
<td>Estimate the most appropriate window size for current bin to best capture the local interaction bias direction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.pipe" title="tadlib.hitad.chromLev.Chrom.pipe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pipe</span></code></a>(seq,&nbsp;start)</td>
<td>Transform an observed sequence into a list of domains.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.plot" title="tadlib.hitad.chromLev.Chrom.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>(start,&nbsp;end,&nbsp;Domains,&nbsp;figname[,&nbsp;…])</td>
<td>Given a genomic region and a domain list, plot corresponding contact heatmap and all domains (represented as diagonal squares) within the region.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="tadlib.hitad.chromLev.Chrom.randomCheck"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randomCheck</span></code></a>(seq[,&nbsp;pthre])</td>
<td>We use chi square test to test the randomness of a sequence by looking at the conversion frequency between neighbors in the sequence.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="tadlib.hitad.chromLev.Chrom.refNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refNoise</span></code></a>(domain)</td>
<td>Return noise level of a domain, which is simply defined as the zero entry ratio of the contact matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="tadlib.hitad.chromLev.Chrom.scoreCache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scoreCache</span></code></a>(domainlist[,&nbsp;cache])</td>
<td>Calculate and cache the TAD scores for any combinations of consecutive bottom domains.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.splitChrom" title="tadlib.hitad.chromLev.Chrom.splitChrom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">splitChrom</span></code></a>(DIs)</td>
<td>Split a chromosome into gap-free regions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="tadlib.hitad.chromLev.Chrom.stablescore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stablescore</span></code></a>(domain[,&nbsp;bases])</td>
<td>Calculate TAD score for the given domain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="tadlib.hitad.chromLev.Chrom.subDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subDomains</span></code></a>(domain,&nbsp;reflist[,&nbsp;clv,&nbsp;aM,&nbsp;W,&nbsp;…])</td>
<td>A recusive method (function) to identify inner domain hierarchy of a TAD (or a domain).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.toArrowhead" title="tadlib.hitad.chromLev.Chrom.toArrowhead"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toArrowhead</span></code></a>(start,&nbsp;end)</td>
<td>Perform Arrowhead transformation on contact matrix of a given genomic region.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.viterbi" title="tadlib.hitad.chromLev.Chrom.viterbi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">viterbi</span></code></a>(seq)</td>
<td>Find the most likely hidden state series using the viterbi algorithm.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>calIS</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>preciseBound</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.calDI">
<code class="descname">calDI</code><span class="sig-paren">(</span><em>windows</em>, <em>start</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.calDI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.calDI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Directionality Index (DI) for each bin with adaptive
window size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>windows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy.ndarray, int32</span></dt>
<dd><p class="first last">Returned by <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.minWindows()</span></code></a>.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Starting bin index, the window size of which is taken from the
1st place of <em>windows</em>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DIs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy ndarray, float</span></dt>
<dd><p class="first last">Calculated adaptive DI array, which has the same size as the
input <em>windows</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.callDomain">
<code class="descname">callDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.callDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.callDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct API for our hierarchical domain identification pipeline:</p>
<ul class="simple">
<li>Adaptively estimate window size for each bin.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.minWindows()</span></code></a>)</li>
<li>Calculate adaptive DIs. (<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.calDI()</span></code></a>)</li>
<li>Iteratively correct adaptive window size and bottom boundary positions.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriIter()</span></code></a>)</li>
<li>Identify TADs based on bottom domains.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxCore()</span></code></a>)</li>
<li>Resolve domain hierarchy within each TAD.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="tadlib.hitad.chromLev.Chrom.fineDomain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.fineDomain()</span></code></a>)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.detectPeaks">
<code class="descname">detectPeaks</code><span class="sig-paren">(</span><em>trends</em>, <em>mph=0</em>, <em>mpd=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.detectPeaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect peaks (local maxima) in a 1-D array intuitively (a peak must
be greater than its immediate neighbors).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>trends</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy ndarray</span></dt>
<dd><p class="first last">Data.</p>
</dd>
<dt><strong>mph</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Only peaks that are greater than this value will be detected.
(Default: 0)</p>
</dd>
<dt><strong>mpd</strong> <span class="classifier-delimiter">:</span> <span class="classifier">positive integer</span></dt>
<dd><p class="first last">Only peaks whose indices are at least separated by this value will
be reported. (Default: 5)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy ndarray</span></dt>
<dd><p class="first last">Indices of peaks detected in <em>trends</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.fineDomain">
<code class="descname">fineDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.fineDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify hierarchical domains within each TAD.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxCore</span></code></a></dt>
<dd>identify TADs</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="tadlib.hitad.chromLev.Chrom.subDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.subDomains</span></code></a></dt>
<dd>resolve domain hierarchy within a given TAD</dd>
</dl>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hierDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified hierarchical domain lists.
Start and end of the domain are in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getDomainList">
<code class="descname">getDomainList</code><span class="sig-paren">(</span><em>byregion</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getDomainList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getDomainList" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine by-region domains into a single list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>byregion</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified domain lists.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DomainList</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A merged domain list of all regions</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getSelfMatrix">
<code class="descname">getSelfMatrix</code><span class="sig-paren">(</span><em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getSelfMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getSelfMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contact matrix of any given region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The region interval in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D numpy ndarray, float</span></dt>
<dd><p class="first last">Sub contact matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getWeightMatrix">
<code class="descname">getWeightMatrix</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>bases=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getWeightMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate weights for each intra-domain interaction by considering
the genomic distance and the local interaction background.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The domain interval in base-pair unit.</p>
</dd>
<dt><strong>bases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of the bottom domains within the given interval.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D numpy.ndarray</span></dt>
<dd><p class="first last">The weight matrix. (An upper triangular matrix)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.idxmatch">
<code class="descname">idxmatch</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.idxmatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Pair interactions of the given domain with the upstream and downstream
interactions under the same genomic distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[start, end]</span></dt>
<dd><p class="first last">Domain interval in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cur_store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt>
<dd><p class="first last">Interactions within the given domain.</p>
</dd>
<dt><strong>up_store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt>
<dd><p class="first last">Corresponding upstream interctions.</p>
</dd>
<dt><strong>down_store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt>
<dd><p class="first last">Corresponding downstream interactions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.iterCore">
<code class="descname">iterCore</code><span class="sig-paren">(</span><em>minDomains</em>, <em>tmpDomains</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.iterCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mismatch ratio for the input two domain lists. Return
1 if <em>minDomains</em> is empty.</p>
<p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriIter()</span></code></a> uses this method to
determine whether to break the iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>minDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Target domains calculated by the last loop.</p>
</dd>
<dt><strong>tmpDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Query domains returned by the current loop.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mismatch ratio.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.maxCore">
<code class="descname">maxCore</code><span class="sig-paren">(</span><em>cache={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.maxCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform TAD identification. We define TADs as domains to optimize
chromosome separation(based on some objective function), which is
solved by using an algorithm like dynamic programming implemented in
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">TAD scores for all combinations of consecutive bottom domains
will be pre-computed and stored in this dict. The keys are
tuples (start, end) representing merged domain intervals.
(Default: {})</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="tadlib.hitad.chromLev.Chrom.scoreCache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.scoreCache</span></code></a></dt>
<dd>Pre-compute TAD scores for all combinations of consecutive bottom domains.</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath</span></code></a></dt>
<dd>find the best TAD list</dd>
</dl>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>maxDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Optimized TADs.</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Cached TAD scores.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.maxscorepath">
<code class="descname">maxscorepath</code><span class="sig-paren">(</span><em>domainlist</em>, <em>cache</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.maxscorepath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation for our proposed algorithm to find the best separation
solution at chromosomal/domain level, given bottom domain list and
pre-computed scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of [start,end]</span></dt>
<dd><p class="first last">List of bottom domain intervals in base-pair unit.</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Pre-computed scores for any combinations of continuous bottom
domains. The keys are intervals of continuous regions in (start,end)
format, and the values are corresponding scores.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bests</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of (sidx, eidx)</span></dt>
<dd><p class="first last">Each element indicates one merged domain of the solution, represented
as (start index, end index) of the input <em>domainlist</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.minCore">
<code class="descname">minCore</code><span class="sig-paren">(</span><em>regionDIs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.minCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.minCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Output domain list for each gap-free region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>regionDIs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Gap-free regions and corresponding adaptive DI arrays.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>minDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Gap-free regions and corresponding identified bottom domain list.
Different from <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.pipe" title="tadlib.hitad.chromLev.Chrom.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.pipe()</span></code></a>, the
start and the end of a domain are in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.minWindows">
<code class="descname">minWindows</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>maxw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.minWindows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate best window size for each bin of a given range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Specify range of the bin indices.</p>
</dd>
<dt><strong>maxw</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum allowable window size.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="tadlib.hitad.chromLev.Chrom.oriWindow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriWindow</span></code></a></dt>
<dd>Window size estimation for a single bin.</dd>
</dl>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>windows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy.ndarray, int32</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.oriIter">
<code class="descname">oriIter</code><span class="sig-paren">(</span><em>minDomains</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.oriIter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratvely approximate adaptive window sizes and return the final
bottom domain list which will be used in subsequent procedures. For
each loop, window sizes are updated according to the latest bottom
domains and next loop will re-run the identification pipeline using
new window sizes. The iteration terminates if domains between two
consecutive loops are very similar (estimated by
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore()</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>minDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Initial domains served as the target domain list for
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore()</span></code></a> at the first
iteration. We set it empty in our pipeline.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.calDI</span></code></a></dt>
<dd>calculate DI values according to input window sizes</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore</span></code></a></dt>
<dd>estimate the degree of divergence between two domain lists</dd>
</dl>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>minDomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified bottom domain lists.
Start and end of the domain are in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.oriWindow">
<code class="descname">oriWindow</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.oriWindow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the most appropriate window size for current bin to best
capture the local interaction bias direction.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="tadlib.hitad.chromLev.Chrom.detectPeaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.detectPeaks</span></code></a></dt>
<dd>detect peaks given a 1-D array</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="tadlib.hitad.chromLev.Chrom.randomCheck"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.randomCheck</span></code></a></dt>
<dd>randomness test for a two-valued (0-1) sequence</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.pipe">
<code class="descname">pipe</code><span class="sig-paren">(</span><em>seq</em>, <em>start</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.pipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an observed sequence into a list of domains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numbpy ndarray, float</span></dt>
<dd><p class="first last">Adaptive DI array for any region.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Chromosome bin index of the <em>seq</em> start.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of domains in the format <code class="docutils literal notranslate"><span class="pre">[start</span> <span class="pre">bin,</span> <span class="pre">end</span> <span class="pre">bin,</span> <span class="pre">noise</span> <span class="pre">level,</span>
<span class="pre">hierarchical</span> <span class="pre">level]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="tadlib.hitad.chromLev.Chrom.refNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.refNoise</span></code></a></dt>
<dd>Calculate the noise level of a given domain</dd>
<dt><a class="reference internal" href="#tadlib.hitad.aligner.BoundSet" title="tadlib.hitad.aligner.BoundSet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.BoundSet</span></code></a></dt>
<dd>where the meanings of the hierarchical level labels are explained in detail.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>start</em>, <em>end</em>, <em>Domains</em>, <em>figname</em>, <em>arrowhead=False</em>, <em>vmin=None</em>, <em>vmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a genomic region and a domain list, plot corresponding contact
heatmap and all domains (represented as diagonal squares) within the
region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The region interval.</p>
</dd>
<dt><strong>Domains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are tuples representing gap-free regions, and values
are corresponding identified domains.</p>
</dd>
<dt><strong>figname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">If not None, the figure will be saved, otherwise it will only be
shown in an interactive window. (Default: None)</p>
</dd>
<dt><strong>arrowhead</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the Arrowhead transformed matrix will be plotted instead
of the raw contact matrix. (Default: False)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.randomCheck">
<code class="descname">randomCheck</code><span class="sig-paren">(</span><em>seq</em>, <em>pthre=0.05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.randomCheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="Permalink to this definition">¶</a></dt>
<dd><p>We use chi square test to test the randomness of a sequence by
looking at the conversion frequency between neighbors in the sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A string containing only ‘1’ or ‘0’. (e.g. ‘101000101’)</p>
</dd>
<dt><strong>pthre</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, 0-1</span></dt>
<dd><p class="first last">Significance level of the hypothesis tests.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if we should reject the null hypothesis (the sequence is
generated randomly) under the selected significance level.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.refNoise">
<code class="descname">refNoise</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.refNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Return noise level of a domain, which is simply defined as the zero
entry ratio of the contact matrix.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.scoreCache">
<code class="descname">scoreCache</code><span class="sig-paren">(</span><em>domainlist</em>, <em>cache={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.scoreCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and cache the TAD scores for any combinations of consecutive
bottom domains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of [start,end]</span></dt>
<dd><p class="first last">List of bottom domain intervals in base-pair unit.</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Cache of the TAD scores. The keys are in (start,end) format,
intervals of continuous regions, and the values are corresponding
calculated scores.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="tadlib.hitad.chromLev.Chrom.stablescore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.stablescore</span></code></a></dt>
<dd>Calculate TAD score of any genomic interval</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.splitChrom">
<code class="descname">splitChrom</code><span class="sig-paren">(</span><em>DIs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.splitChrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.splitChrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a chromosome into gap-free regions. HMM learning and domain
identification procedures will be performed on these regions separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>DIs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numpy ndarray, float</span></dt>
<dd><p class="first last">Adaptive DI array of the whole chromosome. Generally, we detect
runs of zeros in the array as gaps, which will be cut off the
chromosome, making entire chromosome pieces of gap-free regions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chromRegions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, {(start,end):DIs[start:end]}</span></dt>
<dd><p class="first last">The keys are gap-free regions, and the values are corresponding
adaptive DI pieces.</p>
</dd>
<dt><strong>gapbins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set</span></dt>
<dd><p class="first last">Set of bins (in base-pair unit) located in gap regions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.stablescore">
<code class="descname">stablescore</code><span class="sig-paren">(</span><em>domain</em>, <em>bases=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.stablescore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate TAD score for the given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[start, end]</span></dt>
<dd><p class="first last">Domain interval in base-pair unit.</p>
</dd>
<dt><strong>bases</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of bottom domains within the given domain region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">TAD score defined as the enrichment between intra-domain interaction
frequencies and inter-domain interaction frequencies controlling
for the impact of genomic distance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="tadlib.hitad.chromLev.Chrom.idxmatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.idxmatch</span></code></a></dt>
<dd>Pair intra-domain and inter-domain interactions with the same genomic distance</dd>
<dt><a class="reference internal" href="calfea_api.html#tadlib.calfea.analyze.Core.longrange" title="tadlib.calfea.analyze.Core.longrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.calfea.analyze.Core.longrange</span></code></a></dt>
<dd>Assign the weight value for each intra-domain interaction according to the genomic distance and the local interaction background.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.subDomains">
<code class="descname">subDomains</code><span class="sig-paren">(</span><em>domain</em>, <em>reflist</em>, <em>clv=0</em>, <em>aM=None</em>, <em>W=None</em>, <em>subdomains={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.subDomains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="Permalink to this definition">¶</a></dt>
<dd><p>A recusive method (function) to identify inner domain hierarchy
of a TAD (or a domain). Sub-TADs of each level are defined as the
best separation of the outer domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[start, end]</span></dt>
<dd><p class="first last">Outer layer domain interval in base-pair unit.</p>
</dd>
<dt><strong>reflist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of bottom domains within the region of the outer domain.</p>
</dd>
<dt><strong>clv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Global domain level of the outer domain. The TADs have the level
0, the sub-TADs within a TAD have the level 1, and sub-sub-TADs
within a sub-TAD have the level 2, and so forth. (Default: 0)</p>
</dd>
<dt><strong>aM</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D numpy ndarray or None</span></dt>
<dd><p class="first last">Arrowhead matrix of the outer domain. (Default: None)</p>
</dd>
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D numpy ndarray or None</span></dt>
<dd><p class="first last">Weight matrix corresponding to the contact matrix of the outer
domain. See <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="tadlib.hitad.chromLev.Chrom.getWeightMatrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.getWeightMatrix()</span></code></a>
for detailed calculation. (Default: None)</p>
</dd>
<dt><strong>subdomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A container for domains of all hierarchy. The keys are domain
intervals in base-pair unit, and values are corresponding
global levels.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath</span></code></a></dt>
<dd>find the best domain list optimally separating domain-level interactions.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.toArrowhead">
<code class="descname">toArrowhead</code><span class="sig-paren">(</span><em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.toArrowhead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.toArrowhead" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Arrowhead transformation on contact matrix of a given
genomic region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The region interval.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D numpy ndarray, float</span></dt>
<dd><p class="first last">Transformed matrix. (A symmetric matrix)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.viterbi">
<code class="descname">viterbi</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.viterbi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.viterbi" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the most likely hidden state series using the viterbi algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D numbpy ndarray, float</span></dt>
<dd><p class="first last">Adaptive DI array for any region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of hidden state labels. Has the same length as the input
<em>seq</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.chromLev.MultiReps">
<em class="property">class </em><code class="descclassname">tadlib.hitad.chromLev.</code><code class="descname">MultiReps</code><span class="sig-paren">(</span><em>chrom</em>, <em>res</em>, <em>datasets</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps" title="Permalink to this definition">¶</a></dt>
<dd><p>We define <em>MultiReps</em> to:</p>
<ul class="simple">
<li>Hold Hi-C data of the same chromosome from different biological replicates
at the same time</li>
<li>Provide an interface to identify hierarchical domains by using different
replicate data independently and maintain the reproducible domains to
form the final domain list.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Hi-C data resolution in base-pair unit.</p>
</dd>
<dt><strong>datasets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are unique replicate labels, and the values are constructed
<em>Chrom</em> objects by using the Hi-C data of corresponding biological
replicates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code>(tn,&nbsp;qn)</td>
<td>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.callDomain" title="tadlib.hitad.chromLev.MultiReps.callDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callDomain</span></code></a>()</td>
<td>Find reproducible domains between replicates by using our domain-level alignment strategy.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code>(tn,&nbsp;qn)</td>
<td>Return conserved TAD pairs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.getDomainList" title="tadlib.hitad.chromLev.MultiReps.getDomainList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDomainList</span></code></a>(byregion)</td>
<td>Combine by-region domains into a single list.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code>(tn,&nbsp;qn)</td>
<td>Return semi-conserved TAD pairs.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code>(tn,&nbsp;qn)</td>
<td>Return merged region pairs and merged TAD details.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(ti,&nbsp;qi)</td>
<td>Calculate overlap ratio of any two regions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.reproducible" title="tadlib.hitad.chromLev.MultiReps.reproducible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reproducible</span></code></a>(tg,&nbsp;qy)</td>
<td>Subprocess of <em>callDomain</em> for replicate alignment and reproducibility determination.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(tn,&nbsp;qn)</td>
<td>Return split region pairs and split TAD details.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>intersect</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.callDomain">
<code class="descname">callDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.callDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.callDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Find reproducible domains between replicates by using our
domain-level alignment strategy.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.getDomainList">
<code class="descname">getDomainList</code><span class="sig-paren">(</span><em>byregion</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.getDomainList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.getDomainList" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine by-region domains into a single list.</p>
<p>Each domain in the returned list is represented in the format
<code class="docutils literal notranslate"><span class="pre">[chromosome</span> <span class="pre">label,</span> <span class="pre">start</span> <span class="pre">bp,</span> <span class="pre">end</span> <span class="pre">bp,</span> <span class="pre">hierarchical</span> <span class="pre">level]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.reproducible">
<code class="descname">reproducible</code><span class="sig-paren">(</span><em>tg</em>, <em>qy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.reproducible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.reproducible" title="Permalink to this definition">¶</a></dt>
<dd><p>Subprocess of <em>callDomain</em> for replicate alignment and reproducibility
determination.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.genomeLev.Genome">
<em class="property">class </em><code class="descclassname">tadlib.hitad.genomeLev.</code><code class="descname">Genome</code><span class="sig-paren">(</span><em>datasets, balance_type='weight', maxsize=4000000, cache=None, exclude=['chrM', 'chrY'], DIcol='DIs'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Genome</em> is built on top of <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>. We
use it to:</p>
<ul class="simple">
<li>Load bin-level Hi-C data</li>
<li>Initialize, pickle and organize <em>Chrom</em> objects</li>
<li>Call hierarchical domains of each chromosome in parallel</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>datasets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-level dict, {resolution(int):{biological_replicate_label(str):data_path,…}}</span></dt>
<dd><p class="first last"><em>data_path</em> indicates the <em>cool</em> URI under corresponding resolution and biological
replicate label.</p>
</dd>
<dt><strong>maxsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum allowable domain size in base-pair unit. (Default: 4000000)</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">Cache folder path. If None, the folder returned by <a class="reference external" href="https://docs.python.org/3/library/tempfile.html#tempfile.gettempdir" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.gettempdir()</span></code></a> will
be used. (Default: None)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-level dict. {chrom(str):{resolution(int):{biological_replicate_label(str):cachedfile,…}},…}</span></dt>
<dd><p class="first last">Different from the input datasets, it organizes data by chromosome
label, and each bottom-level value indicates one pickled
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a> file under the <em>cache</em> folder.</p>
</dd>
<dt><strong>Results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Final consistent domain list merged from all chromosome results.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.callHierDomain" title="tadlib.hitad.genomeLev.Genome.callHierDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callHierDomain</span></code></a>([cpu_core])</td>
<td>Identify hierarchical domains of each chromosome independently and concurrently, find consistent domains between biological replicates, and finally combine results of all chromosomes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.learning" title="tadlib.hitad.genomeLev.Genome.learning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">learning</span></code></a>([cpu_core])</td>
<td>Prepare training data and learn HMM model parameters for each dataset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.oriHMMParams" title="tadlib.hitad.genomeLev.Genome.oriHMMParams"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriHMMParams</span></code></a>()</td>
<td>Set initial parameters for the Hidden Markov Model (HMM).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.wipeDisk" title="tadlib.hitad.genomeLev.Genome.wipeDisk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wipeDisk</span></code></a>()</td>
<td>Remove catched (pickled) <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a> objects before exiting.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="62%" />
<col width="38%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>outputDomain</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>train_data</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.callHierDomain">
<code class="descname">callHierDomain</code><span class="sig-paren">(</span><em>cpu_core=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.callHierDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.callHierDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify hierarchical domains of each chromosome independently
and concurrently, find consistent domains between biological
replicates, and finally combine results of all chromosomes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cpu_core</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of processes to launch. For now, <em>hitad</em> only supports
parallel computing on a quite high layer, that is, it simply
allocates an uncompleted <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>
object to an idle processor and invokes its <em>callDomain</em> method.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.learning">
<code class="descname">learning</code><span class="sig-paren">(</span><em>cpu_core=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.learning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.learning" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare training data and learn HMM model parameters for each dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cpu_core</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of processes to launch.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.oriHMMParams">
<code class="descname">oriHMMParams</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.oriHMMParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.oriHMMParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Set initial parameters for the Hidden Markov Model (HMM).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>HMMParams</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Has 3 keys: “A”, state transition matrix, “B” (emission probabilities),
specifying parameters (Means, Variances, Weights) of the mixture
Gaussian distributions for each hidden state, and “pi”, indicating
the hidden state weights. This dict will be updated after learning
procedure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.wipeDisk">
<code class="descname">wipeDisk</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.wipeDisk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.wipeDisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove catched (pickled) <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>
objects before exiting.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="domain-loading-and-aligning">
<h1>Domain Loading and Aligning<a class="headerlink" href="#domain-loading-and-aligning" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="tadlib.hitad.aligner.DomainAligner">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">DomainAligner</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is the work horse we define to:</p>
<ol class="arabic simple">
<li>Hold multiple <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances
at the same time.</li>
<li>Perform domain-based hierarchical alignment between any two
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</li>
<li>Define and extract domain-level change types from alignment results
between two <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">two or more <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DomainSets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Pool of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>. The keys are
unique identifiers extracted from <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>,
and the values are corresponding <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
<dt><strong>Results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Container for alignment results between any pair of
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.align" title="tadlib.hitad.aligner.DomainAligner.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(tn,&nbsp;qn)</td>
<td>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.conserved" title="tadlib.hitad.aligner.DomainAligner.conserved"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code></a>(tn,&nbsp;qn)</td>
<td>Return conserved TAD pairs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.inner_changed" title="tadlib.hitad.aligner.DomainAligner.inner_changed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code></a>(tn,&nbsp;qn)</td>
<td>Return semi-conserved TAD pairs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.merged" title="tadlib.hitad.aligner.DomainAligner.merged"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code></a>(tn,&nbsp;qn)</td>
<td>Return merged region pairs and merged TAD details.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(ti,&nbsp;qi)</td>
<td>Calculate overlap ratio of any two regions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.split" title="tadlib.hitad.aligner.DomainAligner.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(tn,&nbsp;qn)</td>
<td>Return split region pairs and split TAD details.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances which are collected by <em>arg</em> during initialization.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The alignment results are organized in a hierarchical way in a
dictionary. The keys are matched chromosome region (corresponds to
either one TAD or several continuous TADs) pairs at the TAD level,
and the values are <a class="reference internal" href="#tadlib.hitad.aligner.Container" title="tadlib.hitad.aligner.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.Container</span></code></a> instances
with <em>info</em> attribute set to be pair of detailed TAD lists; the keys
of these <a class="reference internal" href="#tadlib.hitad.aligner.Container" title="tadlib.hitad.aligner.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.Container</span></code></a> indicate domain
levels, the values again are dictionaries containing sub-alignment
results within the upper-layer TAD region.</p>
<p>You can access the results from <em>Results</em> attribute:
<code class="docutils literal notranslate"><span class="pre">self.Results[tn][qn]</span></code> or <code class="docutils literal notranslate"><span class="pre">self.Results[qn][tn]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.conserved">
<code class="descname">conserved</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.conserved"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.conserved" title="Permalink to this definition">¶</a></dt>
<dd><p>Return conserved TAD pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of tuples</span></dt>
<dd><p class="first last">Each tuple has two elements (domain intervals), corresponding to
<em>tn</em> and <em>qn</em> respectively.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.inner_changed">
<code class="descname">inner_changed</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.inner_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.inner_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return semi-conserved TAD pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of tuples</span></dt>
<dd><p class="first last">Each tuple has two elements (domain intervals), corresponding to
<em>tn</em> and <em>qn</em> respectively.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.merged">
<code class="descname">merged</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.merged"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.merged" title="Permalink to this definition">¶</a></dt>
<dd><p>Return merged region pairs and merged TAD details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are merged region pairs in tuple, and the values are
corresponding TAD list pairs within the region.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Return split region pairs and split TAD details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are split region pairs in tuple, and the values are
corresponding TAD list pairs within the region.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.BoundAligner">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">BoundAligner</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on our hierarchical domain alignment scheme, we also define several
change types on boundary level between two datasets, including conserved
TAD boundary, conserved sub-TAD boundary, disappeared TAD boundary,
disappeared sub-TAD boundary, and TAD-to-sub-TAD boundary switch.</p>
<p>Boundaries are expressed in (chrom,pos) format in this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">two or more <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>byclass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Cache boundary pairs of each change type between datasets.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code>(tn,&nbsp;qn)</td>
<td>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.all_in_one" title="tadlib.hitad.aligner.BoundAligner.all_in_one"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_in_one</span></code></a>(tn,&nbsp;qn,&nbsp;cache)</td>
<td>Parse domain alignment results between <em>tn</em> and <em>qn</em> and cache all detected cases of 6 defined change types.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code>(tn,&nbsp;qn)</td>
<td>Return conserved TAD pairs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds" title="tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved_sub_bounds</span></code></a>(tn,&nbsp;qn)</td>
<td>Return pairs of conserved sub-TAD boundaries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds" title="tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved_tad_bounds</span></code></a>(tn,&nbsp;qn)</td>
<td>Return pairs of conserved TAD boundaries.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.disappeared_sub" title="tadlib.hitad.aligner.BoundAligner.disappeared_sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disappeared_sub</span></code></a>(tn,&nbsp;qn)</td>
<td>Sub-TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.disappeared_tad" title="tadlib.hitad.aligner.BoundAligner.disappeared_tad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disappeared_tad</span></code></a>(tn,&nbsp;qn)</td>
<td>TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code>(tn,&nbsp;qn)</td>
<td>Return semi-conserved TAD pairs.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code>(tn,&nbsp;qn)</td>
<td>Return merged region pairs and merged TAD details.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(ti,&nbsp;qi)</td>
<td>Calculate overlap ratio of any two regions.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(tn,&nbsp;qn)</td>
<td>Return split region pairs and split TAD details.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.sub2tad" title="tadlib.hitad.aligner.BoundAligner.sub2tad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub2tad</span></code></a>(tn,&nbsp;qn)</td>
<td>Return sub-TAD to TAD switch cases.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.tad2sub" title="tadlib.hitad.aligner.BoundAligner.tad2sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tad2sub</span></code></a>(tn,&nbsp;qn)</td>
<td>Return TAD to sub-TAD switch cases.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>pairwise_alignment</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.all_in_one">
<code class="descname">all_in_one</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em>, <em>cache</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.all_in_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.all_in_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse domain alignment results between <em>tn</em> and <em>qn</em> and cache all
detected cases of 6 defined change types.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tn, qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">An empty dictionary.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds">
<code class="descname">conserved_sub_bounds</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.conserved_sub_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pairs of conserved sub-TAD boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys and values indicate sub-TAD boundaries in <em>tn</em> and <em>qn</em>,
respectively.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds">
<code class="descname">conserved_tad_bounds</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.conserved_tad_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pairs of conserved TAD boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys and values indicate TAD boundaries in <em>tn</em> and <em>qn</em>,
respectively.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.disappeared_sub">
<code class="descname">disappeared_sub</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.disappeared_sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.disappeared_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of tuples</span></dt>
<dd><p class="first last">Sub-TAD boundary positions in <em>tn</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.disappeared_tad">
<code class="descname">disappeared_tad</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.disappeared_tad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.disappeared_tad" title="Permalink to this definition">¶</a></dt>
<dd><p>TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of tuples</span></dt>
<dd><p class="first last">TAD boundary positions in <em>tn</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.sub2tad">
<code class="descname">sub2tad</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.sub2tad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.sub2tad" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sub-TAD to TAD switch cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys are sub-TAD boundaries in <em>tn</em>, and values indicate corresponding
TAD boundaries in <em>qn</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.tad2sub">
<code class="descname">tad2sub</code><span class="sig-paren">(</span><em>tn</em>, <em>qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.tad2sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.tad2sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return TAD to sub-TAD switch cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tn, qn: str</strong></dt>
<dd><p class="first last">Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Keys are TAD boundaries in <em>tn</em>, and values indicate corresponding
sub-TAD boundaries in <em>qn</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.DomainSet">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">DomainSet</code><span class="sig-paren">(</span><em>en</em>, <em>domainlist</em>, <em>res</em>, <em>hier=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse and hold a hierarchical domain set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>en</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifier for input domain set.</p>
</dd>
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of domains. See <a class="reference internal" href="#tadlib.hitad.aligner.BoundSet" title="tadlib.hitad.aligner.BoundSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.BoundSet</span></code></a> for
details.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>hier</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether <em>domainlist</em> contains multiple-level domains or not.
(Default: True)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>levs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">set of int</span></dt>
<dd><p class="first last">All possible domain levels contained in <em>domainlist</em>.</p>
</dd>
<dt><strong>bychroms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Bychromosomal rearrangement of <em>domainlist</em>. The keys are chromosome
labels(1,2,…,22,X,Y), and the values are list of [start,end,level].</p>
</dd>
<dt><strong>pretree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nested domain list within any domain interval. Returned by
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>.</p>
</dd>
<dt><strong>subpool</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Domain list within any domain interval.
(<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>lidx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The smallest indices of left domain boundaries in a by-chromosomal
domain list. (<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>ridx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The largest indices of right domain boundaries in a by-chromosomal
domain list. (<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>Domains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Store each TAD and its nested domains as a tree. Each node in the
tree indicates one domain, in particular, the root corresponds to
the TAD, and the leaves correspond to bottom domains.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedDomains</span></code></a>(bychroms)</td>
<td>Pre-parse domain lists for accelerating subsequent calculations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.genDomainTree" title="tadlib.hitad.aligner.DomainSet.genDomainTree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">genDomainTree</span></code></a>(node,&nbsp;pretree,&nbsp;cur)</td>
<td>Recursively generate a tree/sub-tree taking <em>node</em> as starting point.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.getBottoms" title="tadlib.hitad.aligner.DomainSet.getBottoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getBottoms</span></code></a>()</td>
<td>Link bottom domains to corresponding outer TADs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.getregion" title="tadlib.hitad.aligner.DomainSet.getregion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getregion</span></code></a>(chrom,&nbsp;start,&nbsp;end[,&nbsp;lev])</td>
<td>Extract all domains (or domains at specific level) within a given region.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.NestedDomains">
<code class="descname">NestedDomains</code><span class="sig-paren">(</span><em>bychroms</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.NestedDomains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-parse domain lists for accelerating subsequent calculations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bychroms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">By-chromosomal domain lists.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tmpdict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nested domain list within any domain interval. If a domain have
no nested domains, then its value is an empty list.</p>
</dd>
<dt><strong>subpool</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Domain list within any domain interval. Different from <em>tmpdict</em>,
if a domain have no nested domains, the value is a list only
containing itself.</p>
</dd>
<dt><strong>lidx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The smallest indices of left domain boundaries in a by-chromosomal
domain list.</p>
</dd>
<dt><strong>ridx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The largest indices of right domain boundaries in a by-chromosomal
domain list.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.genDomainTree">
<code class="descname">genDomainTree</code><span class="sig-paren">(</span><em>node</em>, <em>pretree</em>, <em>cur</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.genDomainTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.genDomainTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively generate a tree/sub-tree taking <em>node</em> as starting point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>node</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Node</span></dt>
<dd><p class="first last">A dict-like container for current domain.</p>
</dd>
<dt><strong>pretree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nested domain list within any domain interval.
(<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>cur</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Nested domain list within current domain interval.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.getBottoms">
<code class="descname">getBottoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.getBottoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.getBottoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Link bottom domains to corresponding outer TADs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bottoms</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Used to quickly retrieve (bottom domain, TAD) pairs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.getregion">
<code class="descname">getregion</code><span class="sig-paren">(</span><em>chrom</em>, <em>start</em>, <em>end</em>, <em>lev=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.getregion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.getregion" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all domains (or domains at specific level) within a given
region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Domain interval in base-pair unit.</p>
</dd>
<dt><strong>lev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">Specify the desired domain level. (Default: None, domains of all
levels will be returned)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rdomains</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Sorted domain list. Each element corresponds to one domain in the
format <code class="docutils literal notranslate"><span class="pre">[chrom,start,end,level]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.BoundSet">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">BoundSet</code><span class="sig-paren">(</span><em>en</em>, <em>domainlist</em>, <em>res</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundSet" title="Permalink to this definition">¶</a></dt>
<dd><p>As the name suggests, we use <em>BoundSet</em> to hold all bounds of a domain
list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>en</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifier for current set of bounds.</p>
</dd>
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of the domains. Each domain is represented by
<code class="docutils literal notranslate"><span class="pre">[chrom,start,end,level]</span></code>. I think <em>chrom</em>, <em>start</em> and <em>end</em> are
self-explanatory, all you need to keep in mind is that <em>start and
*end</em> should be in base-pair unit. <em>level</em> indicates the hierarchical
level of the domain. In our work, TAD is denoted as 0, sub-TAD is
denoted as 1, and subsequent domain level is denoted as 2, etc.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Resolution of the Hi-C data in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifier.</p>
</dd>
<dt><strong>boundclass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The keys are bound representations (chrom,pos), and the values indicate
corresponding hierarchical level notations. The Level of a bound is
determined by the domain with the lowest level notation. For example,
if we have two domains, [‘1’,100000,500000,0] and [‘1’,100000,200000,1],
according to our definition, the level of (‘1’,200000) is 1, but the
level of (‘1’,100000) is 0.</p>
</dd>
<dt><strong>Bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Sorted bound list. This attribute can be used as the reference
bound list in <a class="reference internal" href="#tadlib.hitad.aligner.SingleBound.align" title="tadlib.hitad.aligner.SingleBound.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.SingleBound.align()</span></code></a>
directly.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.SingleDomain">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">SingleDomain</code><span class="sig-paren">(</span><em>chrom</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>We use <em>SingleDomain</em> to:</p>
<ol class="arabic simple">
<li>Represent a single domain (chrom, start, end).</li>
<li>Map the domain to another domain set</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>start, end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Interval of the domain in base-pair unit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>interval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">[start, end]</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Container for matched details.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.SingleDomain.align" title="tadlib.hitad.aligner.SingleDomain.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(qy)</td>
<td>Find the domain <em>D</em> in <em>qy</em> maximizing the overlap ratio.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#tadlib.hitad.aligner.SingleDomain.overlap" title="tadlib.hitad.aligner.SingleDomain.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(ti,&nbsp;qi)</td>
<td>Calculate overlap ratio of any two regions.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.SingleDomain.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>qy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the domain <em>D</em> in <em>qy</em> maximizing the overlap ratio. Binary
search method is used internally for accelerating the search process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instance</span></dt>
<dd><p class="first last">Reference domain set. (Recall sequence mapping and reference
genome)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The matched details are stored in <em>cache</em> using the unique identifier
of <em>qy</em> (<code class="docutils literal notranslate"><span class="pre">qy.Label</span></code>) as the key, the value is also a dict with 2
keys: <em>hitdomain</em> records the matched domain interval in
(chrom,start,end) format, and <em>hitoverlap</em> records the overlap ratio
between the hitdomain and current query domain.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.SingleDomain.overlap">
<code class="descname">overlap</code><span class="sig-paren">(</span><em>ti</em>, <em>qi</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate overlap ratio of any two regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ti, qi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Interval ([start,end]) of the region.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>OR</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, 0-1</span></dt>
<dd><p class="first last">Overlap ratio.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.SingleBound">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">SingleBound</code><span class="sig-paren">(</span><em>chrom</em>, <em>pos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleBound" title="Permalink to this definition">¶</a></dt>
<dd><p><em>SingleBound</em> is defined to:</p>
<ul class="simple">
<li>Represent a single bound (chrom, pos)</li>
<li>Map the bound to a pool of bounds</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Bound position on the chromosome.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chrom</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chromosome label.</p>
</dd>
<dt><strong>pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Position on the chromosome.</p>
</dd>
<dt><strong>cache</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Container for matched details.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#tadlib.hitad.aligner.SingleBound.align" title="tadlib.hitad.aligner.SingleBound.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(qn,&nbsp;qb,&nbsp;tol)</td>
<td>Map the bound to <em>qb</em> using the binary search method.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.SingleBound.align">
<code class="descname">align</code><span class="sig-paren">(</span><em>qn</em>, <em>qb</em>, <em>tol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleBound.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleBound.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the bound to <em>qb</em> using the binary search method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qn</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Unique identifier for <em>qb</em>.</p>
</dd>
<dt><strong>qb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd><p class="first last">Reference bound (remember reference genome?) list. Each element
is a tuple (chrom, pos) representing a single bound. And the list
must be sorted in advance for binary search.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Mismatch tolerance. If the genomic distance between the bound
and the best hit is less than this value, we say we have found
a match, otherwise the bound is missed in <em>qb</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Internally, the matched details will be stored in <em>cache</em> under the
key <em>qn</em>, the value is also a dict recording the matched bound
index (midx) and the indices of the matched neighbors (nindices).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.Container">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">Container</code><span class="sig-paren">(</span><em>info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#Container"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.Container" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict-like. Used in the organizing of domain alignment results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Pair of domain lists from two domain sets.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code>($type,&nbsp;iterable[,&nbsp;value])</td>
<td>Returns a new dict with keys from iterable and values equal to value.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(k[,d])</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code>(k[,d])</td>
<td>If key is not found, d is returned if given, otherwise KeyError is raised</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code>()</td>
<td>2-tuple; but raise KeyError if D is empty.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code>(k[,d])</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>([E,&nbsp;]**F)</td>
<td>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.Node">
<em class="property">class </em><code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Dick-like. We use it to represent nodes of a hierarchical domain tree
in <em>DomainSet</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">Domain interval represented by [chrom,start,end].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code>($type,&nbsp;iterable[,&nbsp;value])</td>
<td>Returns a new dict with keys from iterable and values equal to value.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(k[,d])</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code>(k[,d])</td>
<td>If key is not found, d is returned if given, otherwise KeyError is raised</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code>()</td>
<td>2-tuple; but raise KeyError if D is empty.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code>(k[,d])</td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>([E,&nbsp;]**F)</td>
<td>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.readHierDomain">
<code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">readHierDomain</code><span class="sig-paren">(</span><em>domainfile</em>, <em>pre=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#readHierDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.readHierDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Load hierarchical domain list from a text file.</p>
<p>The source file should contain 4 columns indicating chromosome label
(1,2,…,X,Y), domain start (bp), domain end (bp), and hierarchical level
(0,1,2,…), respectively.</p>
<p>In our paper, TAD is denoted as level 0, sub-TAD is denoted as level 1,
and subsequent domain level is denoted as level 2, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domainfile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Domain file path.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Each element of the list indicates one domain represented by
[chrom,start,end,level].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.readPlainDomain">
<code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">readPlainDomain</code><span class="sig-paren">(</span><em>domainfile</em>, <em>pre='chr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#readPlainDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.readPlainDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Load domain list from a text file.</p>
<p>The source file should contain 3 columns indicating chromosome name,
domain start (bp) and domain end (bp), respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domainfile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Domain file path.</p>
</dd>
<dt><strong>pre</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Leading string of the chromosome name. (Default: chr)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Each element indicates one domain represented by
[chrom(leading string removed),start,end].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#tadlib.hitad.aligner.hierFormat" title="tadlib.hitad.aligner.hierFormat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.hierFormat</span></code></a></dt>
<dd>parse hierarchical relationships between domains</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.hierFormat">
<code class="descclassname">tadlib.hitad.aligner.</code><code class="descname">hierFormat</code><span class="sig-paren">(</span><em>domainlist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#hierFormat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.hierFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the nested/hierarchical relationships between domains, and
transform the input [chrom,start,end] format domains into a format
including hierarchical level information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Domains with the format [chrom,start,end].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domainlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Domains with the format [chrom,start,end,level].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017, XiaoTao Wang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/hitad_api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/XiaoTaoWang/TADLib" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>