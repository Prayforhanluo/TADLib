
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Hierarchical TAD Identification &#8212; TADLib 0.4.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Detect Single-level TAD" href="domaincaller.html" />
    <link rel="prev" title="Hierarchical TAD" href="hitad.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">TADLib</a></h1>



<p class="blurb">A Library to Explore Chromatin Interaction Patterns for Topologically Associating Domains</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=XiaoTaoWang&repo=TADLib&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Install TADLib</a></li>
<li class="toctree-l1"><a class="reference internal" href="calfea.html">Aggregation Preference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="hitad.html">Hierarchical TAD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="hitad.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="hitad.html#snapshot">Snapshot</a></li>
<li class="toctree-l2"><a class="reference internal" href="hitad.html#tutorial">Tutorial</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="hitad.html#id1">API Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Hierarchical TAD Identification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domain-loading-and-aligning">Domain Loading and Aligning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="domaincaller.html">Detect Single-level TAD</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualize.html">TAD visulization</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Release Notes</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="hierarchical-tad-identification">
<h1>Hierarchical TAD Identification<a class="headerlink" href="#hierarchical-tad-identification" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="tadlib.hitad.chromLev.Chrom">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.chromLev.</code><code class="sig-name descname">Chrom</code><span class="sig-paren">(</span><em class="sig-param">chrom</em>, <em class="sig-param">res</em>, <em class="sig-param">hicdata</em>, <em class="sig-param">replabel</em>, <em class="sig-param">maxapart=4000000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Chrom</em> is defined to:</p>
<ul class="simple">
<li><p>Hold Hi-C data within a certain chromosome</p></li>
<li><p>Identify hierarchical domains in 4 steps: 1.Calculate adaptive DIs.
2.Identify original candidate bounds by 5-state Gaussian mixture Hidden
Markov Model using adaptive DIs as input. 3.Select TAD bounds from
candidate bounds. 4.Recursively identify inner domain structures of each TAD.</p></li>
<li><p>Visualize any region of the chromosome. Hierarchical domains will be
plotted as boxes along with the diagonal of the heatmap, and adaptive
DI track will be placed on top of the heatmap.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>hicdata</strong><span class="classifier">CSR sparse matrix</span></dt><dd><p>Bin-level Hi-C matrix of the specified chromosome.</p>
</dd>
<dt><strong>replabel</strong><span class="classifier">str</span></dt><dd><p>Biological replicate label.</p>
</dd>
<dt><strong>maxapart</strong><span class="classifier">int</span></dt><dd><p>Maximum allowable TAD size in base-pair unit. (Default: 4000000)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Resolution in base-pair unit.</p>
</dd>
<dt><strong>maxapart</strong><span class="classifier">int</span></dt><dd><p>Maximum allowable TAD size.</p>
</dd>
<dt><strong>replabel</strong><span class="classifier">str</span></dt><dd><p>Biological replicate label.</p>
</dd>
<dt><strong>chromLen</strong><span class="classifier">int</span></dt><dd><p>Total bin number of the chromosome.</p>
</dd>
<dt><strong>rawMatrix</strong><span class="classifier">sparse matrix in Compressed Sparse Row format</span></dt><dd><p>CSR sparse matrix is used to extract Hi-C data by slicing conveniently
while guarantee low memory overhead.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calDI</span></code></a>(self, windows, start)</p></td>
<td><p>Calculate Directionality Index (DI) for each bin with adaptive window size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.callDomain" title="tadlib.hitad.chromLev.Chrom.callDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callDomain</span></code></a>(self)</p></td>
<td><p>Direct API for our hierarchical domain identification pipeline:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="tadlib.hitad.chromLev.Chrom.detectPeaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detectPeaks</span></code></a>(self, trends[, mph, mpd])</p></td>
<td><p>Detect peaks (local maxima) in a 1-D array intuitively (a peak must be greater than its immediate neighbors).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="tadlib.hitad.chromLev.Chrom.fineDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fineDomain</span></code></a>(self)</p></td>
<td><p>Identify hierarchical domains within each TAD.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getDomainList" title="tadlib.hitad.chromLev.Chrom.getDomainList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDomainList</span></code></a>(self, byregion)</p></td>
<td><p>Combine by-region domains into a single list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getSelfMatrix" title="tadlib.hitad.chromLev.Chrom.getSelfMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSelfMatrix</span></code></a>(self, start, end)</p></td>
<td><p>Return the contact matrix of any given region.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="tadlib.hitad.chromLev.Chrom.getWeightMatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getWeightMatrix</span></code></a>(self, start, end[, bases])</p></td>
<td><p>Calculate weights for each intra-domain interaction by considering the genomic distance and the local interaction background.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="tadlib.hitad.chromLev.Chrom.idxmatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">idxmatch</span></code></a>(self, domain)</p></td>
<td><p>Pair interactions of the given domain with the upstream and downstream interactions under the same genomic distance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iterCore</span></code></a>(self, minDomains, tmpDomains)</p></td>
<td><p>Calculate the mismatch ratio for the input two domain lists.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxCore</span></code></a>(self[, cache])</p></td>
<td><p>Perform TAD identification.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxscorepath</span></code></a>(self, domainlist, cache)</p></td>
<td><p>An implementation for our proposed algorithm to find the best separation solution at chromosomal/domain level, given bottom domain list and pre-computed scores.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minCore" title="tadlib.hitad.chromLev.Chrom.minCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minCore</span></code></a>(self, regionDIs)</p></td>
<td><p>Output domain list for each gap-free region.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minWindows</span></code></a>(self, start, end, maxw)</p></td>
<td><p>Estimate best window size for each bin of a given range.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriIter</span></code></a>(self, minDomains)</p></td>
<td><p>Iteratvely approximate adaptive window sizes and return the final bottom domain list which will be used in subsequent procedures.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="tadlib.hitad.chromLev.Chrom.oriWindow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriWindow</span></code></a>(self, P)</p></td>
<td><p>Estimate the most appropriate window size for current bin to best capture the local interaction bias direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.pipe" title="tadlib.hitad.chromLev.Chrom.pipe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pipe</span></code></a>(self, seq, start)</p></td>
<td><p>Transform an observed sequence into a list of domains.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.plot" title="tadlib.hitad.chromLev.Chrom.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>(self, start, end, Domains, figname[, …])</p></td>
<td><p>Given a genomic region and a domain list, plot corresponding contact heatmap and all domains (represented as diagonal squares) within the region.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="tadlib.hitad.chromLev.Chrom.randomCheck"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randomCheck</span></code></a>(self, seq[, pthre])</p></td>
<td><p>We use chi square test to test the randomness of a sequence by looking at the conversion frequency between neighbors in the sequence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="tadlib.hitad.chromLev.Chrom.refNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refNoise</span></code></a>(self, domain)</p></td>
<td><p>Return noise level of a domain, which is simply defined as the zero entry ratio of the contact matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="tadlib.hitad.chromLev.Chrom.scoreCache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scoreCache</span></code></a>(self, domainlist[, cache])</p></td>
<td><p>Calculate and cache the TAD scores for any combinations of consecutive bottom domains.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.splitChrom" title="tadlib.hitad.chromLev.Chrom.splitChrom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">splitChrom</span></code></a>(self, DIs)</p></td>
<td><p>Split a chromosome into gap-free regions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="tadlib.hitad.chromLev.Chrom.stablescore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stablescore</span></code></a>(self, domain[, bases])</p></td>
<td><p>Calculate TAD score for the given domain.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="tadlib.hitad.chromLev.Chrom.subDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subDomains</span></code></a>(self, domain, reflist[, clv, aM, …])</p></td>
<td><p>A recusive method (function) to identify inner domain hierarchy of a TAD (or a domain).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.toArrowhead" title="tadlib.hitad.chromLev.Chrom.toArrowhead"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toArrowhead</span></code></a>(self, start, end)</p></td>
<td><p>Perform Arrowhead transformation on contact matrix of a given genomic region.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.viterbi" title="tadlib.hitad.chromLev.Chrom.viterbi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">viterbi</span></code></a>(self, seq)</p></td>
<td><p>Find the most likely hidden state series using the viterbi algorithm.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>calIS</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>preciseBound</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.calDI">
<code class="sig-name descname">calDI</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">windows</em>, <em class="sig-param">start</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.calDI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.calDI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Directionality Index (DI) for each bin with adaptive
window size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>windows</strong><span class="classifier">1-D numpy.ndarray, int32</span></dt><dd><p>Returned by <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.minWindows()</span></code></a>.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Starting bin index, the window size of which is taken from the
1st place of <em>windows</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DIs</strong><span class="classifier">1-D numpy ndarray, float</span></dt><dd><p>Calculated adaptive DI array, which has the same size as the
input <em>windows</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.callDomain">
<code class="sig-name descname">callDomain</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.callDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.callDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct API for our hierarchical domain identification pipeline:</p>
<ul class="simple">
<li><p>Adaptively estimate window size for each bin.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="tadlib.hitad.chromLev.Chrom.minWindows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.minWindows()</span></code></a>)</p></li>
<li><p>Calculate adaptive DIs. (<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.calDI()</span></code></a>)</p></li>
<li><p>Iteratively correct adaptive window size and bottom boundary positions.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriIter()</span></code></a>)</p></li>
<li><p>Identify TADs based on bottom domains.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxCore()</span></code></a>)</p></li>
<li><p>Resolve domain hierarchy within each TAD.
(<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="tadlib.hitad.chromLev.Chrom.fineDomain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.fineDomain()</span></code></a>)</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.detectPeaks">
<code class="sig-name descname">detectPeaks</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">trends</em>, <em class="sig-param">mph=0</em>, <em class="sig-param">mpd=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.detectPeaks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect peaks (local maxima) in a 1-D array intuitively (a peak must
be greater than its immediate neighbors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trends</strong><span class="classifier">1-D numpy ndarray</span></dt><dd><p>Data.</p>
</dd>
<dt><strong>mph</strong><span class="classifier">float</span></dt><dd><p>Only peaks that are greater than this value will be detected.
(Default: 0)</p>
</dd>
<dt><strong>mpd</strong><span class="classifier">positive integer</span></dt><dd><p>Only peaks whose indices are at least separated by this value will
be reported. (Default: 5)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">1-D numpy ndarray</span></dt><dd><p>Indices of peaks detected in <em>trends</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.fineDomain">
<code class="sig-name descname">fineDomain</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.fineDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.fineDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify hierarchical domains within each TAD.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="tadlib.hitad.chromLev.Chrom.maxCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxCore</span></code></a></dt><dd><p>identify TADs</p>
</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="tadlib.hitad.chromLev.Chrom.subDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.subDomains</span></code></a></dt><dd><p>resolve domain hierarchy within a given TAD</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hierDomains</strong><span class="classifier">dict</span></dt><dd><p>The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified hierarchical domain lists.
Start and end of the domain are in base-pair unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getDomainList">
<code class="sig-name descname">getDomainList</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">byregion</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getDomainList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getDomainList" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine by-region domains into a single list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>byregion</strong><span class="classifier">dict</span></dt><dd><p>The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified domain lists.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DomainList</strong><span class="classifier">list</span></dt><dd><p>A merged domain list of all regions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getSelfMatrix">
<code class="sig-name descname">getSelfMatrix</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getSelfMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getSelfMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contact matrix of any given region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>The region interval in base-pair unit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Matrix</strong><span class="classifier">2-D numpy ndarray, float</span></dt><dd><p>Sub contact matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.getWeightMatrix">
<code class="sig-name descname">getWeightMatrix</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">bases=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.getWeightMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate weights for each intra-domain interaction by considering
the genomic distance and the local interaction background.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>The domain interval in base-pair unit.</p>
</dd>
<dt><strong>bases</strong><span class="classifier">list</span></dt><dd><p>List of the bottom domains within the given interval.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>W</strong><span class="classifier">2-D numpy.ndarray</span></dt><dd><p>The weight matrix. (An upper triangular matrix)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.idxmatch">
<code class="sig-name descname">idxmatch</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domain</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.idxmatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Pair interactions of the given domain with the upstream and downstream
interactions under the same genomic distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domain</strong><span class="classifier">[start, end]</span></dt><dd><p>Domain interval in base-pair unit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cur_store</strong><span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt><dd><p>Interactions within the given domain.</p>
</dd>
<dt><strong>up_store</strong><span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt><dd><p>Corresponding upstream interctions.</p>
</dd>
<dt><strong>down_store</strong><span class="classifier">tuple, (x-coordinates, y-coordinates, interaction frequencies)</span></dt><dd><p>Corresponding downstream interactions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.iterCore">
<code class="sig-name descname">iterCore</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">minDomains</em>, <em class="sig-param">tmpDomains</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.iterCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mismatch ratio for the input two domain lists. Return
1 if <em>minDomains</em> is empty.</p>
<p><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="tadlib.hitad.chromLev.Chrom.oriIter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriIter()</span></code></a> uses this method to
determine whether to break the iteration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minDomains</strong><span class="classifier">dict</span></dt><dd><p>Target domains calculated by the last loop.</p>
</dd>
<dt><strong>tmpDomains</strong><span class="classifier">dict</span></dt><dd><p>Query domains returned by the current loop.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Mismatch ratio.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.maxCore">
<code class="sig-name descname">maxCore</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cache={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.maxCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.maxCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform TAD identification. We define TADs as domains to optimize
chromosome separation(based on some objective function), which is
solved by using an algorithm like dynamic programming implemented in
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>TAD scores for all combinations of consecutive bottom domains
will be pre-computed and stored in this dict. The keys are
tuples (start, end) representing merged domain intervals.
(Default: {})</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="tadlib.hitad.chromLev.Chrom.scoreCache"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.scoreCache</span></code></a></dt><dd><p>Pre-compute TAD scores for all combinations of consecutive bottom domains.</p>
</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath</span></code></a></dt><dd><p>find the best TAD list</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>maxDomains</strong><span class="classifier">dict</span></dt><dd><p>Optimized TADs.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>Cached TAD scores.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.maxscorepath">
<code class="sig-name descname">maxscorepath</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domainlist</em>, <em class="sig-param">cache</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.maxscorepath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="Permalink to this definition">¶</a></dt>
<dd><p>An implementation for our proposed algorithm to find the best separation
solution at chromosomal/domain level, given bottom domain list and
pre-computed scores.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list of [start,end]</span></dt><dd><p>List of bottom domain intervals in base-pair unit.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>Pre-computed scores for any combinations of continuous bottom
domains. The keys are intervals of continuous regions in (start,end)
format, and the values are corresponding scores.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bests</strong><span class="classifier">set of (sidx, eidx)</span></dt><dd><p>Each element indicates one merged domain of the solution, represented
as (start index, end index) of the input <em>domainlist</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.minCore">
<code class="sig-name descname">minCore</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">regionDIs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.minCore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.minCore" title="Permalink to this definition">¶</a></dt>
<dd><p>Output domain list for each gap-free region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>regionDIs</strong><span class="classifier">dict</span></dt><dd><p>Gap-free regions and corresponding adaptive DI arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>minDomains</strong><span class="classifier">dict</span></dt><dd><p>Gap-free regions and corresponding identified bottom domain list.
Different from <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.pipe" title="tadlib.hitad.chromLev.Chrom.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.pipe()</span></code></a>, the
start and the end of a domain are in base-pair unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.minWindows">
<code class="sig-name descname">minWindows</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">maxw</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.minWindows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.minWindows" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate best window size for each bin of a given range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>Specify range of the bin indices.</p>
</dd>
<dt><strong>maxw</strong><span class="classifier">int</span></dt><dd><p>Maximum allowable window size.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="tadlib.hitad.chromLev.Chrom.oriWindow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.oriWindow</span></code></a></dt><dd><p>Window size estimation for a single bin.</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>windows</strong><span class="classifier">1-D numpy.ndarray, int32</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.oriIter">
<code class="sig-name descname">oriIter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">minDomains</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.oriIter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.oriIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iteratvely approximate adaptive window sizes and return the final
bottom domain list which will be used in subsequent procedures. For
each loop, window sizes are updated according to the latest bottom
domains and next loop will re-run the identification pipeline using
new window sizes. The iteration terminates if domains between two
consecutive loops are very similar (estimated by
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minDomains</strong><span class="classifier">dict</span></dt><dd><p>Initial domains served as the target domain list for
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore()</span></code></a> at the first
iteration. We set it empty in our pipeline.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.calDI" title="tadlib.hitad.chromLev.Chrom.calDI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.calDI</span></code></a></dt><dd><p>calculate DI values according to input window sizes</p>
</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.iterCore" title="tadlib.hitad.chromLev.Chrom.iterCore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.iterCore</span></code></a></dt><dd><p>estimate the degree of divergence between two domain lists</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>minDomains</strong><span class="classifier">dict</span></dt><dd><p>The keys are tuples representing gap-free regions of the chromosome,
and the values are corresponding identified bottom domain lists.
Start and end of the domain are in base-pair unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.oriWindow">
<code class="sig-name descname">oriWindow</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">P</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.oriWindow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.oriWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the most appropriate window size for current bin to best
capture the local interaction bias direction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.detectPeaks" title="tadlib.hitad.chromLev.Chrom.detectPeaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.detectPeaks</span></code></a></dt><dd><p>detect peaks given a 1-D array</p>
</dd>
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="tadlib.hitad.chromLev.Chrom.randomCheck"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.randomCheck</span></code></a></dt><dd><p>randomness test for a two-valued (0-1) sequence</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.pipe">
<code class="sig-name descname">pipe</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">seq</em>, <em class="sig-param">start</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.pipe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an observed sequence into a list of domains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">1-D numbpy ndarray, float</span></dt><dd><p>Adaptive DI array for any region.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Chromosome bin index of the <em>seq</em> start.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>domains</strong><span class="classifier">list</span></dt><dd><p>List of domains in the format <code class="docutils literal notranslate"><span class="pre">[start</span> <span class="pre">bin,</span> <span class="pre">end</span> <span class="pre">bin,</span> <span class="pre">noise</span> <span class="pre">level,</span>
<span class="pre">hierarchical</span> <span class="pre">level]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="tadlib.hitad.chromLev.Chrom.refNoise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.refNoise</span></code></a></dt><dd><p>Calculate the noise level of a given domain</p>
</dd>
<dt><a class="reference internal" href="#tadlib.hitad.aligner.BoundSet" title="tadlib.hitad.aligner.BoundSet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.BoundSet</span></code></a></dt><dd><p>where the meanings of the hierarchical level labels are explained in detail.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">Domains</em>, <em class="sig-param">figname</em>, <em class="sig-param">arrowhead=False</em>, <em class="sig-param">vmin=None</em>, <em class="sig-param">vmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a genomic region and a domain list, plot corresponding contact
heatmap and all domains (represented as diagonal squares) within the
region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>The region interval.</p>
</dd>
<dt><strong>Domains</strong><span class="classifier">dict</span></dt><dd><p>The keys are tuples representing gap-free regions, and values
are corresponding identified domains.</p>
</dd>
<dt><strong>figname</strong><span class="classifier">str or None</span></dt><dd><p>If not None, the figure will be saved, otherwise it will only be
shown in an interactive window. (Default: None)</p>
</dd>
<dt><strong>arrowhead</strong><span class="classifier">bool</span></dt><dd><p>If True, the Arrowhead transformed matrix will be plotted instead
of the raw contact matrix. (Default: False)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.randomCheck">
<code class="sig-name descname">randomCheck</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">seq</em>, <em class="sig-param">pthre=0.05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.randomCheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.randomCheck" title="Permalink to this definition">¶</a></dt>
<dd><p>We use chi square test to test the randomness of a sequence by
looking at the conversion frequency between neighbors in the sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">str</span></dt><dd><p>A string containing only ‘1’ or ‘0’. (e.g. ‘101000101’)</p>
</dd>
<dt><strong>pthre</strong><span class="classifier">float, 0-1</span></dt><dd><p>Significance level of the hypothesis tests.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reject</strong><span class="classifier">bool</span></dt><dd><p>True if we should reject the null hypothesis (the sequence is
generated randomly) under the selected significance level.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.refNoise">
<code class="sig-name descname">refNoise</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domain</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.refNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.refNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Return noise level of a domain, which is simply defined as the zero
entry ratio of the contact matrix.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.scoreCache">
<code class="sig-name descname">scoreCache</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domainlist</em>, <em class="sig-param">cache={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.scoreCache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.scoreCache" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and cache the TAD scores for any combinations of consecutive
bottom domains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list of [start,end]</span></dt><dd><p>List of bottom domain intervals in base-pair unit.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>Cache of the TAD scores. The keys are in (start,end) format,
intervals of continuous regions, and the values are corresponding
calculated scores.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="tadlib.hitad.chromLev.Chrom.stablescore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.stablescore</span></code></a></dt><dd><p>Calculate TAD score of any genomic interval</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.splitChrom">
<code class="sig-name descname">splitChrom</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">DIs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.splitChrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.splitChrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Split a chromosome into gap-free regions. HMM learning and domain
identification procedures will be performed on these regions separately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>DIs</strong><span class="classifier">1-D numpy ndarray, float</span></dt><dd><p>Adaptive DI array of the whole chromosome. Generally, we detect
runs of zeros in the array as gaps, which will be cut off the
chromosome, making entire chromosome pieces of gap-free regions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chromRegions</strong><span class="classifier">dict, {(start,end):DIs[start:end]}</span></dt><dd><p>The keys are gap-free regions, and the values are corresponding
adaptive DI pieces.</p>
</dd>
<dt><strong>gapbins</strong><span class="classifier">set</span></dt><dd><p>Set of bins (in base-pair unit) located in gap regions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.stablescore">
<code class="sig-name descname">stablescore</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domain</em>, <em class="sig-param">bases=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.stablescore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.stablescore" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate TAD score for the given domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domain</strong><span class="classifier">[start, end]</span></dt><dd><p>Domain interval in base-pair unit.</p>
</dd>
<dt><strong>bases</strong><span class="classifier">list</span></dt><dd><p>List of bottom domains within the given domain region.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inout</strong><span class="classifier">float</span></dt><dd><p>TAD score defined as the enrichment between intra-domain interaction
frequencies and inter-domain interaction frequencies controlling
for the impact of genomic distance.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.idxmatch" title="tadlib.hitad.chromLev.Chrom.idxmatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.idxmatch</span></code></a></dt><dd><p>Pair intra-domain and inter-domain interactions with the same genomic distance</p>
</dd>
<dt><a class="reference internal" href="calfea_api.html#tadlib.calfea.analyze.Core.longrange" title="tadlib.calfea.analyze.Core.longrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.calfea.analyze.Core.longrange</span></code></a></dt><dd><p>Assign the weight value for each intra-domain interaction according to the genomic distance and the local interaction background.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.subDomains">
<code class="sig-name descname">subDomains</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">domain</em>, <em class="sig-param">reflist</em>, <em class="sig-param">clv=0</em>, <em class="sig-param">aM=None</em>, <em class="sig-param">W=None</em>, <em class="sig-param">subdomains={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.subDomains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.subDomains" title="Permalink to this definition">¶</a></dt>
<dd><p>A recusive method (function) to identify inner domain hierarchy
of a TAD (or a domain). Sub-TADs of each level are defined as the
best separation of the outer domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domain</strong><span class="classifier">[start, end]</span></dt><dd><p>Outer layer domain interval in base-pair unit.</p>
</dd>
<dt><strong>reflist</strong><span class="classifier">list</span></dt><dd><p>List of bottom domains within the region of the outer domain.</p>
</dd>
<dt><strong>clv</strong><span class="classifier">int</span></dt><dd><p>Global domain level of the outer domain. The TADs have the level
0, the sub-TADs within a TAD have the level 1, and sub-sub-TADs
within a sub-TAD have the level 2, and so forth. (Default: 0)</p>
</dd>
<dt><strong>aM</strong><span class="classifier">2-D numpy ndarray or None</span></dt><dd><p>Arrowhead matrix of the outer domain. (Default: None)</p>
</dd>
<dt><strong>W</strong><span class="classifier">2-D numpy ndarray or None</span></dt><dd><p>Weight matrix corresponding to the contact matrix of the outer
domain. See <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.getWeightMatrix" title="tadlib.hitad.chromLev.Chrom.getWeightMatrix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.getWeightMatrix()</span></code></a>
for detailed calculation. (Default: None)</p>
</dd>
<dt><strong>subdomains</strong><span class="classifier">dict</span></dt><dd><p>A container for domains of all hierarchy. The keys are domain
intervals in base-pair unit, and values are corresponding
global levels.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.chromLev.Chrom.maxscorepath" title="tadlib.hitad.chromLev.Chrom.maxscorepath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom.maxscorepath</span></code></a></dt><dd><p>find the best domain list optimally separating domain-level interactions.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.toArrowhead">
<code class="sig-name descname">toArrowhead</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.toArrowhead"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.toArrowhead" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Arrowhead transformation on contact matrix of a given
genomic region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>The region interval.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A</strong><span class="classifier">2-D numpy ndarray, float</span></dt><dd><p>Transformed matrix. (A symmetric matrix)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.Chrom.viterbi">
<code class="sig-name descname">viterbi</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">seq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#Chrom.viterbi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.Chrom.viterbi" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the most likely hidden state series using the viterbi algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seq</strong><span class="classifier">1-D numbpy ndarray, float</span></dt><dd><p>Adaptive DI array for any region.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>path</strong><span class="classifier">list</span></dt><dd><p>List of hidden state labels. Has the same length as the input
<em>seq</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.chromLev.MultiReps">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.chromLev.</code><code class="sig-name descname">MultiReps</code><span class="sig-paren">(</span><em class="sig-param">chrom</em>, <em class="sig-param">res</em>, <em class="sig-param">datasets</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps" title="Permalink to this definition">¶</a></dt>
<dd><p>We define <em>MultiReps</em> to:</p>
<ul class="simple">
<li><p>Hold Hi-C data of the same chromosome from different biological replicates
at the same time</p></li>
<li><p>Provide an interface to identify hierarchical domains by using different
replicate data independently and maintain the reproducible domains to
form the final domain list.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Hi-C data resolution in base-pair unit.</p>
</dd>
<dt><strong>datasets</strong><span class="classifier">dict</span></dt><dd><p>The keys are unique replicate labels, and the values are constructed
<em>Chrom</em> objects by using the Hi-C data of corresponding biological
replicates.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code>(self, tn, qn)</p></td>
<td><p>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.callDomain" title="tadlib.hitad.chromLev.MultiReps.callDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callDomain</span></code></a>(self)</p></td>
<td><p>Find reproducible domains between replicates by using our domain-level alignment strategy.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code>(self, tn, qn)</p></td>
<td><p>Return conserved TAD pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.getDomainList" title="tadlib.hitad.chromLev.MultiReps.getDomainList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDomainList</span></code></a>(self, byregion)</p></td>
<td><p>Combine by-region domains into a single list.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code>(self, tn, qn)</p></td>
<td><p>Return semi-conserved TAD pairs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code>(self, tn, qn)</p></td>
<td><p>Return merged region pairs and merged TAD details.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(self, ti, qi)</p></td>
<td><p>Calculate overlap ratio of any two regions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.chromLev.MultiReps.reproducible" title="tadlib.hitad.chromLev.MultiReps.reproducible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reproducible</span></code></a>(self, tg, qy)</p></td>
<td><p>Subprocess of <em>callDomain</em> for replicate alignment and reproducibility determination.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(self, tn, qn)</p></td>
<td><p>Return split region pairs and split TAD details.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>intersect</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.callDomain">
<code class="sig-name descname">callDomain</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.callDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.callDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Find reproducible domains between replicates by using our
domain-level alignment strategy.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.getDomainList">
<code class="sig-name descname">getDomainList</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">byregion</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.getDomainList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.getDomainList" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine by-region domains into a single list.</p>
<p>Each domain in the returned list is represented in the format
<code class="docutils literal notranslate"><span class="pre">[chromosome</span> <span class="pre">label,</span> <span class="pre">start</span> <span class="pre">bp,</span> <span class="pre">end</span> <span class="pre">bp,</span> <span class="pre">hierarchical</span> <span class="pre">level]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.chromLev.MultiReps.reproducible">
<code class="sig-name descname">reproducible</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tg</em>, <em class="sig-param">qy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/chromLev.html#MultiReps.reproducible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.chromLev.MultiReps.reproducible" title="Permalink to this definition">¶</a></dt>
<dd><p>Subprocess of <em>callDomain</em> for replicate alignment and reproducibility
determination.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.genomeLev.Genome">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.genomeLev.</code><code class="sig-name descname">Genome</code><span class="sig-paren">(</span><em class="sig-param">datasets, balance_type='weight', maxsize=4000000, cache=None, exclude=['chrM', 'chrY'], DIcol='DIs'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Genome</em> is built on top of <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>. We
use it to:</p>
<ul class="simple">
<li><p>Load bin-level Hi-C data</p></li>
<li><p>Initialize, pickle and organize <em>Chrom</em> objects</p></li>
<li><p>Call hierarchical domains of each chromosome in parallel</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>datasets</strong><span class="classifier">2-level dict, {resolution(int):{biological_replicate_label(str):data_path,…}}</span></dt><dd><p><em>data_path</em> indicates the <em>cool</em> URI under corresponding resolution and biological
replicate label.</p>
</dd>
<dt><strong>maxsize</strong><span class="classifier">int</span></dt><dd><p>Maximum allowable domain size in base-pair unit. (Default: 4000000)</p>
</dd>
<dt><strong>cache</strong><span class="classifier">str or None</span></dt><dd><p>Cache folder path. If None, the folder returned by <a class="reference external" href="https://docs.python.org/2.7/library/tempfile.html#tempfile.gettempdir" title="(in Python v2.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">tempfile.gettempdir()</span></code></a> will
be used. (Default: None)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">3-level dict. {chrom(str):{resolution(int):{biological_replicate_label(str):cachedfile,…}},…}</span></dt><dd><p>Different from the input datasets, it organizes data by chromosome
label, and each bottom-level value indicates one pickled
<a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a> file under the <em>cache</em> folder.</p>
</dd>
<dt><strong>Results</strong><span class="classifier">list</span></dt><dd><p>Final consistent domain list merged from all chromosome results.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.callHierDomain" title="tadlib.hitad.genomeLev.Genome.callHierDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">callHierDomain</span></code></a>(self[, cpu_core])</p></td>
<td><p>Identify hierarchical domains of each chromosome independently and concurrently, find consistent domains between biological replicates, and finally combine results of all chromosomes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.learning" title="tadlib.hitad.genomeLev.Genome.learning"><code class="xref py py-obj docutils literal notranslate"><span class="pre">learning</span></code></a>(self[, cpu_core])</p></td>
<td><p>Prepare training data and learn HMM model parameters for each dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.oriHMMParams" title="tadlib.hitad.genomeLev.Genome.oriHMMParams"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oriHMMParams</span></code></a>(self)</p></td>
<td><p>Set initial parameters for the Hidden Markov Model (HMM).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.genomeLev.Genome.wipeDisk" title="tadlib.hitad.genomeLev.Genome.wipeDisk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wipeDisk</span></code></a>(self)</p></td>
<td><p>Remove catched (pickled) <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a> objects before exiting.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>outputDomain</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>train_data</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.callHierDomain">
<code class="sig-name descname">callHierDomain</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cpu_core=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.callHierDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.callHierDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify hierarchical domains of each chromosome independently
and concurrently, find consistent domains between biological
replicates, and finally combine results of all chromosomes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cpu_core</strong><span class="classifier">int</span></dt><dd><p>Number of processes to launch. For now, <em>hitad</em> only supports
parallel computing on a quite high layer, that is, it simply
allocates an uncompleted <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>
object to an idle processor and invokes its <em>callDomain</em> method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.learning">
<code class="sig-name descname">learning</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cpu_core=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.learning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.learning" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare training data and learn HMM model parameters for each dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cpu_core</strong><span class="classifier">int</span></dt><dd><p>Number of processes to launch.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.oriHMMParams">
<code class="sig-name descname">oriHMMParams</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.oriHMMParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.oriHMMParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Set initial parameters for the Hidden Markov Model (HMM).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>HMMParams</strong><span class="classifier">dict</span></dt><dd><p>Has 3 keys: “A”, state transition matrix, “B” (emission probabilities),
specifying parameters (Means, Variances, Weights) of the mixture
Gaussian distributions for each hidden state, and “pi”, indicating
the hidden state weights. This dict will be updated after learning
procedure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.genomeLev.Genome.wipeDisk">
<code class="sig-name descname">wipeDisk</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/genomeLev.html#Genome.wipeDisk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.genomeLev.Genome.wipeDisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove catched (pickled) <a class="reference internal" href="#tadlib.hitad.chromLev.Chrom" title="tadlib.hitad.chromLev.Chrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.chromLev.Chrom</span></code></a>
objects before exiting.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="domain-loading-and-aligning">
<h1>Domain Loading and Aligning<a class="headerlink" href="#domain-loading-and-aligning" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="tadlib.hitad.aligner.DomainAligner">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">DomainAligner</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is the work horse we define to:</p>
<ol class="arabic simple">
<li><p>Hold multiple <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances
at the same time.</p></li>
<li><p>Perform domain-based hierarchical alignment between any two
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p></li>
<li><p>Define and extract domain-level change types from alignment results
between two <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p></li>
</ol>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>args</strong><span class="classifier">two or more <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DomainSets</strong><span class="classifier">dict</span></dt><dd><p>Pool of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>. The keys are
unique identifiers extracted from <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>,
and the values are corresponding <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
<dt><strong>Results</strong><span class="classifier">dict</span></dt><dd><p>Container for alignment results between any pair of
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.align" title="tadlib.hitad.aligner.DomainAligner.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(self, tn, qn)</p></td>
<td><p>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.conserved" title="tadlib.hitad.aligner.DomainAligner.conserved"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code></a>(self, tn, qn)</p></td>
<td><p>Return conserved TAD pairs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.inner_changed" title="tadlib.hitad.aligner.DomainAligner.inner_changed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code></a>(self, tn, qn)</p></td>
<td><p>Return semi-conserved TAD pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.merged" title="tadlib.hitad.aligner.DomainAligner.merged"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code></a>(self, tn, qn)</p></td>
<td><p>Return merged region pairs and merged TAD details.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(self, ti, qi)</p></td>
<td><p>Calculate overlap ratio of any two regions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainAligner.split" title="tadlib.hitad.aligner.DomainAligner.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(self, tn, qn)</p></td>
<td><p>Return split region pairs and split TAD details.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances which are collected by <em>arg</em> during initialization.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The alignment results are organized in a hierarchical way in a
dictionary. The keys are matched chromosome region (corresponds to
either one TAD or several continuous TADs) pairs at the TAD level,
and the values are <a class="reference internal" href="#tadlib.hitad.aligner.Container" title="tadlib.hitad.aligner.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.Container</span></code></a> instances
with <em>info</em> attribute set to be pair of detailed TAD lists; the keys
of these <a class="reference internal" href="#tadlib.hitad.aligner.Container" title="tadlib.hitad.aligner.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.Container</span></code></a> indicate domain
levels, the values again are dictionaries containing sub-alignment
results within the upper-layer TAD region.</p>
<p>You can access the results from <em>Results</em> attribute:
<code class="docutils literal notranslate"><span class="pre">self.Results[tn][qn]</span></code> or <code class="docutils literal notranslate"><span class="pre">self.Results[qn][tn]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.conserved">
<code class="sig-name descname">conserved</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.conserved"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.conserved" title="Permalink to this definition">¶</a></dt>
<dd><p>Return conserved TAD pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">set of tuples</span></dt><dd><p>Each tuple has two elements (domain intervals), corresponding to
<em>tn</em> and <em>qn</em> respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.inner_changed">
<code class="sig-name descname">inner_changed</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.inner_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.inner_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return semi-conserved TAD pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">set of tuples</span></dt><dd><p>Each tuple has two elements (domain intervals), corresponding to
<em>tn</em> and <em>qn</em> respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.merged">
<code class="sig-name descname">merged</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.merged"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.merged" title="Permalink to this definition">¶</a></dt>
<dd><p>Return merged region pairs and merged TAD details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>The keys are merged region pairs in tuple, and the values are
corresponding TAD list pairs within the region.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainAligner.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainAligner.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainAligner.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Return split region pairs and split TAD details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>The keys are split region pairs in tuple, and the values are
corresponding TAD list pairs within the region.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.BoundAligner">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">BoundAligner</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner" title="Permalink to this definition">¶</a></dt>
<dd><p>Based on our hierarchical domain alignment scheme, we also define several
change types on boundary level between two datasets, including conserved
TAD boundary, conserved sub-TAD boundary, disappeared TAD boundary,
disappeared sub-TAD boundary, and TAD-to-sub-TAD boundary switch.</p>
<p>Boundaries are expressed in (chrom,pos) format in this class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>args</strong><span class="classifier">two or more <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instances</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>byclass</strong><span class="classifier">dict</span></dt><dd><p>Cache boundary pairs of each change type between datasets.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code>(self, tn, qn)</p></td>
<td><p>Construct hierarchical alignment between <em>tn</em> and <em>qn</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.all_in_one" title="tadlib.hitad.aligner.BoundAligner.all_in_one"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_in_one</span></code></a>(self, tn, qn, cache)</p></td>
<td><p>Parse domain alignment results between <em>tn</em> and <em>qn</em> and cache all detected cases of 6 defined change types.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved</span></code>(self, tn, qn)</p></td>
<td><p>Return conserved TAD pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds" title="tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved_sub_bounds</span></code></a>(self, tn, qn)</p></td>
<td><p>Return pairs of conserved sub-TAD boundaries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds" title="tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conserved_tad_bounds</span></code></a>(self, tn, qn)</p></td>
<td><p>Return pairs of conserved TAD boundaries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.disappeared_sub" title="tadlib.hitad.aligner.BoundAligner.disappeared_sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disappeared_sub</span></code></a>(self, tn, qn)</p></td>
<td><p>Sub-TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.disappeared_tad" title="tadlib.hitad.aligner.BoundAligner.disappeared_tad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disappeared_tad</span></code></a>(self, tn, qn)</p></td>
<td><p>TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_changed</span></code>(self, tn, qn)</p></td>
<td><p>Return semi-conserved TAD pairs.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merged</span></code>(self, tn, qn)</p></td>
<td><p>Return merged region pairs and merged TAD details.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code>(self, ti, qi)</p></td>
<td><p>Calculate overlap ratio of any two regions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(self, tn, qn)</p></td>
<td><p>Return split region pairs and split TAD details.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.sub2tad" title="tadlib.hitad.aligner.BoundAligner.sub2tad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub2tad</span></code></a>(self, tn, qn)</p></td>
<td><p>Return sub-TAD to TAD switch cases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.BoundAligner.tad2sub" title="tadlib.hitad.aligner.BoundAligner.tad2sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tad2sub</span></code></a>(self, tn, qn)</p></td>
<td><p>Return TAD to sub-TAD switch cases.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 69%" />
<col style="width: 31%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>pairwise_alignment</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.all_in_one">
<code class="sig-name descname">all_in_one</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em>, <em class="sig-param">cache</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.all_in_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.all_in_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse domain alignment results between <em>tn</em> and <em>qn</em> and cache all
detected cases of 6 defined change types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>An empty dictionary.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds">
<code class="sig-name descname">conserved_sub_bounds</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.conserved_sub_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.conserved_sub_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pairs of conserved sub-TAD boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>Keys and values indicate sub-TAD boundaries in <em>tn</em> and <em>qn</em>,
respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds">
<code class="sig-name descname">conserved_tad_bounds</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.conserved_tad_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.conserved_tad_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pairs of conserved TAD boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>Keys and values indicate TAD boundaries in <em>tn</em> and <em>qn</em>,
respectively.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.disappeared_sub">
<code class="sig-name descname">disappeared_sub</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.disappeared_sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.disappeared_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">set of tuples</span></dt><dd><p>Sub-TAD boundary positions in <em>tn</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.disappeared_tad">
<code class="sig-name descname">disappeared_tad</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.disappeared_tad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.disappeared_tad" title="Permalink to this definition">¶</a></dt>
<dd><p>TAD boundaries that exist in <em>tn</em>, but disappear in <em>qn</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">set of tuples</span></dt><dd><p>TAD boundary positions in <em>tn</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.sub2tad">
<code class="sig-name descname">sub2tad</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.sub2tad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.sub2tad" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sub-TAD to TAD switch cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>Keys are sub-TAD boundaries in <em>tn</em>, and values indicate corresponding
TAD boundaries in <em>qn</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.BoundAligner.tad2sub">
<code class="sig-name descname">tad2sub</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">tn</em>, <em class="sig-param">qn</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundAligner.tad2sub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundAligner.tad2sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Return TAD to sub-TAD switch cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tn, qn: str</strong></dt><dd><p>Unique identifiers of <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a>
instances.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pairs</strong><span class="classifier">dict</span></dt><dd><p>Keys are TAD boundaries in <em>tn</em>, and values indicate corresponding
sub-TAD boundaries in <em>qn</em>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.DomainSet">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">DomainSet</code><span class="sig-paren">(</span><em class="sig-param">en</em>, <em class="sig-param">domainlist</em>, <em class="sig-param">res</em>, <em class="sig-param">hier=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse and hold a hierarchical domain set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>en</strong><span class="classifier">str</span></dt><dd><p>Unique identifier for input domain set.</p>
</dd>
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>List of domains. See <a class="reference internal" href="#tadlib.hitad.aligner.BoundSet" title="tadlib.hitad.aligner.BoundSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.BoundSet</span></code></a> for
details.</p>
</dd>
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>hier</strong><span class="classifier">bool</span></dt><dd><p>Whether <em>domainlist</em> contains multiple-level domains or not.
(Default: True)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Resolution of the Hi-C data in base-pair unit.</p>
</dd>
<dt><strong>levs</strong><span class="classifier">set of int</span></dt><dd><p>All possible domain levels contained in <em>domainlist</em>.</p>
</dd>
<dt><strong>bychroms</strong><span class="classifier">dict</span></dt><dd><p>Bychromosomal rearrangement of <em>domainlist</em>. The keys are chromosome
labels(1,2,…,22,X,Y), and the values are list of [start,end,level].</p>
</dd>
<dt><strong>pretree</strong><span class="classifier">dict</span></dt><dd><p>Nested domain list within any domain interval. Returned by
<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>.</p>
</dd>
<dt><strong>subpool</strong><span class="classifier">dict</span></dt><dd><p>Domain list within any domain interval.
(<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>lidx</strong><span class="classifier">dict</span></dt><dd><p>The smallest indices of left domain boundaries in a by-chromosomal
domain list. (<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>ridx</strong><span class="classifier">dict</span></dt><dd><p>The largest indices of right domain boundaries in a by-chromosomal
domain list. (<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>Domains</strong><span class="classifier">dict</span></dt><dd><p>Store each TAD and its nested domains as a tree. Each node in the
tree indicates one domain, in particular, the root corresponds to
the TAD, and the leaves correspond to bottom domains.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedDomains</span></code></a>(self, bychroms)</p></td>
<td><p>Pre-parse domain lists for accelerating subsequent calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.genDomainTree" title="tadlib.hitad.aligner.DomainSet.genDomainTree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">genDomainTree</span></code></a>(self, node, pretree, cur)</p></td>
<td><p>Recursively generate a tree/sub-tree taking <em>node</em> as starting point.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.getBottoms" title="tadlib.hitad.aligner.DomainSet.getBottoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getBottoms</span></code></a>(self)</p></td>
<td><p>Link bottom domains to corresponding outer TADs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.getregion" title="tadlib.hitad.aligner.DomainSet.getregion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getregion</span></code></a>(self, chrom, start, end[, lev])</p></td>
<td><p>Extract all domains (or domains at specific level) within a given region.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.NestedDomains">
<code class="sig-name descname">NestedDomains</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">bychroms</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.NestedDomains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-parse domain lists for accelerating subsequent calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bychroms</strong><span class="classifier">dict</span></dt><dd><p>By-chromosomal domain lists.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tmpdict</strong><span class="classifier">dict</span></dt><dd><p>Nested domain list within any domain interval. If a domain have
no nested domains, then its value is an empty list.</p>
</dd>
<dt><strong>subpool</strong><span class="classifier">dict</span></dt><dd><p>Domain list within any domain interval. Different from <em>tmpdict</em>,
if a domain have no nested domains, the value is a list only
containing itself.</p>
</dd>
<dt><strong>lidx</strong><span class="classifier">dict</span></dt><dd><p>The smallest indices of left domain boundaries in a by-chromosomal
domain list.</p>
</dd>
<dt><strong>ridx</strong><span class="classifier">dict</span></dt><dd><p>The largest indices of right domain boundaries in a by-chromosomal
domain list.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.genDomainTree">
<code class="sig-name descname">genDomainTree</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">node</em>, <em class="sig-param">pretree</em>, <em class="sig-param">cur</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.genDomainTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.genDomainTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively generate a tree/sub-tree taking <em>node</em> as starting point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>node</strong><span class="classifier">Node</span></dt><dd><p>A dict-like container for current domain.</p>
</dd>
<dt><strong>pretree</strong><span class="classifier">dict</span></dt><dd><p>Nested domain list within any domain interval.
(<a class="reference internal" href="#tadlib.hitad.aligner.DomainSet.NestedDomains" title="tadlib.hitad.aligner.DomainSet.NestedDomains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet.NestedDomains()</span></code></a>)</p>
</dd>
<dt><strong>cur</strong><span class="classifier">list</span></dt><dd><p>Nested domain list within current domain interval.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.getBottoms">
<code class="sig-name descname">getBottoms</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.getBottoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.getBottoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Link bottom domains to corresponding outer TADs.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bottoms</strong><span class="classifier">dict</span></dt><dd><p>Used to quickly retrieve (bottom domain, TAD) pairs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.DomainSet.getregion">
<code class="sig-name descname">getregion</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">chrom</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em>, <em class="sig-param">lev=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#DomainSet.getregion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.DomainSet.getregion" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all domains (or domains at specific level) within a given
region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>Domain interval in base-pair unit.</p>
</dd>
<dt><strong>lev</strong><span class="classifier">int or None</span></dt><dd><p>Specify the desired domain level. (Default: None, domains of all
levels will be returned)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rdomains</strong><span class="classifier">list</span></dt><dd><p>Sorted domain list. Each element corresponds to one domain in the
format <code class="docutils literal notranslate"><span class="pre">[chrom,start,end,level]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.BoundSet">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">BoundSet</code><span class="sig-paren">(</span><em class="sig-param">en</em>, <em class="sig-param">domainlist</em>, <em class="sig-param">res</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#BoundSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.BoundSet" title="Permalink to this definition">¶</a></dt>
<dd><p>As the name suggests, we use <em>BoundSet</em> to hold all bounds of a domain
list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>en</strong><span class="classifier">str</span></dt><dd><p>Unique identifier for current set of bounds.</p>
</dd>
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>List of the domains. Each domain is represented by
<code class="docutils literal notranslate"><span class="pre">[chrom,start,end,level]</span></code>. I think <em>chrom</em>, <em>start</em> and <em>end</em> are
self-explanatory, all you need to keep in mind is that <em>start and
*end</em> should be in base-pair unit. <em>level</em> indicates the hierarchical
level of the domain. In our work, TAD is denoted as 0, sub-TAD is
denoted as 1, and subsequent domain level is denoted as 2, etc.</p>
</dd>
<dt><strong>res</strong><span class="classifier">int</span></dt><dd><p>Resolution of the Hi-C data in base-pair unit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Label</strong><span class="classifier">str</span></dt><dd><p>Unique identifier.</p>
</dd>
<dt><strong>boundclass</strong><span class="classifier">dict</span></dt><dd><p>The keys are bound representations (chrom,pos), and the values indicate
corresponding hierarchical level notations. The Level of a bound is
determined by the domain with the lowest level notation. For example,
if we have two domains, [‘1’,100000,500000,0] and [‘1’,100000,200000,1],
according to our definition, the level of (‘1’,200000) is 1, but the
level of (‘1’,100000) is 0.</p>
</dd>
<dt><strong>Bounds</strong><span class="classifier">list</span></dt><dd><p>Sorted bound list. This attribute can be used as the reference
bound list in <a class="reference internal" href="#tadlib.hitad.aligner.SingleBound.align" title="tadlib.hitad.aligner.SingleBound.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.SingleBound.align()</span></code></a>
directly.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.SingleDomain">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">SingleDomain</code><span class="sig-paren">(</span><em class="sig-param">chrom</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>We use <em>SingleDomain</em> to:</p>
<ol class="arabic simple">
<li><p>Represent a single domain (chrom, start, end).</p></li>
<li><p>Map the domain to another domain set</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>start, end</strong><span class="classifier">int</span></dt><dd><p>Interval of the domain in base-pair unit.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>interval</strong><span class="classifier">list</span></dt><dd><p>[start, end]</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>Container for matched details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.SingleDomain.align" title="tadlib.hitad.aligner.SingleDomain.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(self, qy)</p></td>
<td><p>Find the domain <em>D</em> in <em>qy</em> maximizing the overlap ratio.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.SingleDomain.overlap" title="tadlib.hitad.aligner.SingleDomain.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(self, ti, qi)</p></td>
<td><p>Calculate overlap ratio of any two regions.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.SingleDomain.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">qy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the domain <em>D</em> in <em>qy</em> maximizing the overlap ratio. Binary
search method is used internally for accelerating the search process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>qy</strong><span class="classifier">a <a class="reference internal" href="#tadlib.hitad.aligner.DomainSet" title="tadlib.hitad.aligner.DomainSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.DomainSet</span></code></a> instance</span></dt><dd><p>Reference domain set. (Recall sequence mapping and reference
genome)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The matched details are stored in <em>cache</em> using the unique identifier
of <em>qy</em> (<code class="docutils literal notranslate"><span class="pre">qy.Label</span></code>) as the key, the value is also a dict with 2
keys: <em>hitdomain</em> records the matched domain interval in
(chrom,start,end) format, and <em>hitoverlap</em> records the overlap ratio
between the hitdomain and current query domain.</p>
</dd></dl>

<dl class="method">
<dt id="tadlib.hitad.aligner.SingleDomain.overlap">
<code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ti</em>, <em class="sig-param">qi</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleDomain.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleDomain.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate overlap ratio of any two regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ti, qi</strong><span class="classifier">list</span></dt><dd><p>Interval ([start,end]) of the region.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>OR</strong><span class="classifier">float, 0-1</span></dt><dd><p>Overlap ratio.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.SingleBound">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">SingleBound</code><span class="sig-paren">(</span><em class="sig-param">chrom</em>, <em class="sig-param">pos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleBound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleBound" title="Permalink to this definition">¶</a></dt>
<dd><p><em>SingleBound</em> is defined to:</p>
<ul class="simple">
<li><p>Represent a single bound (chrom, pos)</p></li>
<li><p>Map the bound to a pool of bounds</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>pos</strong><span class="classifier">int</span></dt><dd><p>Bound position on the chromosome.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>chrom</strong><span class="classifier">str</span></dt><dd><p>Chromosome label.</p>
</dd>
<dt><strong>pos</strong><span class="classifier">int</span></dt><dd><p>Position on the chromosome.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">dict</span></dt><dd><p>Container for matched details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tadlib.hitad.aligner.SingleBound.align" title="tadlib.hitad.aligner.SingleBound.align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code></a>(self, qn, qb, tol)</p></td>
<td><p>Map the bound to <em>qb</em> using the binary search method.</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tadlib.hitad.aligner.SingleBound.align">
<code class="sig-name descname">align</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">qn</em>, <em class="sig-param">qb</em>, <em class="sig-param">tol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#SingleBound.align"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.SingleBound.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the bound to <em>qb</em> using the binary search method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>qn</strong><span class="classifier">str</span></dt><dd><p>Unique identifier for <em>qb</em>.</p>
</dd>
<dt><strong>qb</strong><span class="classifier">list of tuples</span></dt><dd><p>Reference bound (remember reference genome?) list. Each element
is a tuple (chrom, pos) representing a single bound. And the list
must be sorted in advance for binary search.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">int</span></dt><dd><p>Mismatch tolerance. If the genomic distance between the bound
and the best hit is less than this value, we say we have found
a match, otherwise the bound is missed in <em>qb</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Internally, the matched details will be stored in <em>cache</em> under the
key <em>qn</em>, the value is also a dict recording the matched bound
index (midx) and the indices of the matched neighbors (nindices).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.Container">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">Container</code><span class="sig-paren">(</span><em class="sig-param">info</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#Container"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.Container" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict-like. Used in the organizing of domain alignment results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>info</strong><span class="classifier">list</span></dt><dd><p>Pair of domain lists from two domain sets.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code>(iterable[, value])</p></td>
<td><p>Create a new dictionary with keys from iterable and values set to value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(self, key[, default])</p></td>
<td><p>Return the value for key if key is in the dictionary, else default.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code>()</p></td>
<td><p>If key is not found, d is returned if given, otherwise KeyError is raised</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code>()</p></td>
<td><p>2-tuple; but raise KeyError if D is empty.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code>(self, key[, default])</p></td>
<td><p>Insert key with a value of default if key is not in the dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>()</p></td>
<td><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="tadlib.hitad.aligner.Node">
<em class="property">class </em><code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">Node</code><span class="sig-paren">(</span><em class="sig-param">bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#Node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Dick-like. We use it to represent nodes of a hierarchical domain tree
in <em>DomainSet</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bounds</strong><span class="classifier">list or None</span></dt><dd><p>Domain interval represented by [chrom,start,end].</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromkeys</span></code>(iterable[, value])</p></td>
<td><p>Create a new dictionary with keys from iterable and values set to value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code>(self, key[, default])</p></td>
<td><p>Return the value for key if key is in the dictionary, else default.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code>()</p></td>
<td><p>If key is not found, d is returned if given, otherwise KeyError is raised</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code>()</p></td>
<td><p>2-tuple; but raise KeyError if D is empty.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code>(self, key[, default])</p></td>
<td><p>Insert key with a value of default if key is not in the dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code>()</p></td>
<td><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v In either case, this is followed by: for k in F:  D[k] = F[k]</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code>()</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.readHierDomain">
<code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">readHierDomain</code><span class="sig-paren">(</span><em class="sig-param">domainfile</em>, <em class="sig-param">pre=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#readHierDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.readHierDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Load hierarchical domain list from a text file.</p>
<p>The source file should contain 4 columns indicating chromosome label
(1,2,…,X,Y), domain start (bp), domain end (bp), and hierarchical level
(0,1,2,…), respectively.</p>
<p>In our paper, TAD is denoted as level 0, sub-TAD is denoted as level 1,
and subsequent domain level is denoted as level 2, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domainfile</strong><span class="classifier">str</span></dt><dd><p>Domain file path.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>Each element of the list indicates one domain represented by
[chrom,start,end,level].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.readPlainDomain">
<code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">readPlainDomain</code><span class="sig-paren">(</span><em class="sig-param">domainfile</em>, <em class="sig-param">pre='chr'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#readPlainDomain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.readPlainDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Load domain list from a text file.</p>
<p>The source file should contain 3 columns indicating chromosome name,
domain start (bp) and domain end (bp), respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domainfile</strong><span class="classifier">str</span></dt><dd><p>Domain file path.</p>
</dd>
<dt><strong>pre</strong><span class="classifier">str</span></dt><dd><p>Leading string of the chromosome name. (Default: chr)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>Each element indicates one domain represented by
[chrom(leading string removed),start,end].</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#tadlib.hitad.aligner.hierFormat" title="tadlib.hitad.aligner.hierFormat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tadlib.hitad.aligner.hierFormat</span></code></a></dt><dd><p>parse hierarchical relationships between domains</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="tadlib.hitad.aligner.hierFormat">
<code class="sig-prename descclassname">tadlib.hitad.aligner.</code><code class="sig-name descname">hierFormat</code><span class="sig-paren">(</span><em class="sig-param">domainlist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tadlib/hitad/aligner.html#hierFormat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tadlib.hitad.aligner.hierFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve the nested/hierarchical relationships between domains, and
transform the input [chrom,start,end] format domains into a format
including hierarchical level information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>Domains with the format [chrom,start,end].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>domainlist</strong><span class="classifier">list</span></dt><dd><p>Domains with the format [chrom,start,end,level].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2017, XiaoTao Wang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/hitad_api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/XiaoTaoWang/TADLib" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>